# __init__.py# Copyright (C) 2025 ['chai chaimee']# Licensed under GNU General Public License. See COPYING.txt for details.import globalPluginHandlerimport uiimport apiimport scriptHandlerfrom NVDAObjects import NVDAObjectfrom NVDAObjects.UIA import UIAfrom controlTypes import Role, Stateimport addonHandlerfrom comtypes.client import CreateObjectfrom logHandler import logimport guiimport wximport gui.guiHelperfrom .config import loadConfig, saveConfigfrom keyboardHandler import KeyboardInputGestureimport corefrom threading import Timer, Threadimport winUserimport osimport sysimport subprocessimport shutilimport tonesfrom .xPlorerManager import xPlorerSettingsPanel, ExplorerManageraddonHandler.initTranslation()class RenameDialog(wx.Dialog):    def __init__(self, parent, fileName):        super().__init__(parent, title="")        self.fileName = fileName        self.newName = None        self.InitUI()            def InitUI(self):        mainSizer = wx.BoxSizer(wx.VERTICAL)        sHelper = gui.guiHelper.BoxSizerHelper(self, orientation=wx.VERTICAL)                name, ext = os.path.splitext(self.fileName)                self.nameCtrl = sHelper.addItem(wx.TextCtrl(self, value=name))        self.nameCtrl.SelectAll()                if ext and ext.startswith('.'):            ext = ext[1:]        self.extCtrl = sHelper.addItem(wx.TextCtrl(self, value=ext))                btnSizer = self.CreateButtonSizer(wx.OK | wx.CANCEL)        sHelper.addItem(btnSizer, flag=wx.ALIGN_CENTER)                self.SetSizer(mainSizer)        mainSizer.Fit(self)                self.CentreOnScreen()        self.nameCtrl.SetFocus()                self.Bind(wx.EVT_BUTTON, self.OnOk, id=wx.ID_OK)        self.Bind(wx.EVT_BUTTON, self.OnCancel, id=wx.ID_CANCEL)        self.Bind(wx.EVT_TEXT_ENTER, self.OnOk)        self.Bind(wx.EVT_CLOSE, self.OnClose)            def OnOk(self, event):        name = self.nameCtrl.Value.strip()        ext = self.extCtrl.Value.strip()                if not name:            ui.message(_("File name cannot be empty"))            return                    if ext:            ext = "." + ext        self.newName = name + ext        self.EndModal(wx.ID_OK)            def OnCancel(self, event):        self.EndModal(wx.ID_CANCEL)            def OnClose(self, event):        self.EndModal(wx.ID_CANCEL)class GlobalPlugin(globalPluginHandler.GlobalPlugin):    scriptCategory = _("xPlorer")        def __init__(self):        super().__init__()        self.objShellApp = CreateObject("Shell.Application")        self.objFSO = CreateObject("scripting.FileSystemObject")        gui.settingsDialogs.NVDASettingsDialog.categoryClasses.append(xPlorerSettingsPanel)        self.manager = ExplorerManager(self)        self.renameDialog = None        self.progressDialog = None        self.compressThread = None        self.cancelled = False        self.lastExplorerHwnd = None    def terminate(self):        super().terminate()        gui.settingsDialogs.NVDASettingsDialog.categoryClasses.remove(xPlorerSettingsPanel)        if self.renameDialog:            try:                self.renameDialog.Destroy()            except:                pass        if self.progressDialog:            try:                self.progressDialog.Destroy()            except:                pass        if self.compressThread and self.compressThread.is_alive():            self.compressThread.join(timeout=1.0)    def _WinObjects(self):        focus = api.getFocusObject()        log.debug(f"Focus name: {focus.name}, role: {focus.role}, appName: {getattr(focus.appModule, 'appName', 'N/A')}")        objShellWin = self.objShellApp.Windows()        oAppWnd = api.getForegroundObject()        hAppWnd = oAppWnd.windowHandle                LookingForTheWindow = True        i = 0        while LookingForTheWindow and i < objShellWin.Count:            oWItem = objShellWin.Item(i)            hElement = oWItem.hwnd            log.debug(f"Checking window {i}: hwnd={hElement}, matches={hElement == hAppWnd}")            if hElement == hAppWnd:                LookingForTheWindow = False                i = i - 1            i = i + 1        if i >= objShellWin.Count:            log.debug("No matching Explorer window found")            ui.message(_("No matching Explorer window found"))            return None, None        oWItem = objShellWin.Item(i)        if oWItem.document and hasattr(oWItem.document, 'FocusedItem') and oWItem.document.FocusedItem:            path = oWItem.document.FocusedItem.Path            log.debug(f"FocusedItem.Path: {path}, Focus Name: {focus.name}")            if self.objFSO.FileExists(path):                oElement = self.objFSO.GetFile(path)                IsFolder = 0            elif not self.objFSO.DriveExists(path) and self.objFSO.FolderExists(path):                oElement = self.objFSO.GetFolder(path)                IsFolder = 1            elif self.objFSO.DriveExists(path):                oElement = self.objFSO.GetDrive(path)                IsFolder = 2            else:                log.debug("Properties not available for path")                ui.message(_("Properties not available"))                return None, None            return (oElement, IsFolder)        log.debug("No focused item found")        ui.message(_("No focused item found"))        return None, None    def _RecalcSize(self, iResult, iTotalSize=0):        fResult = float(iResult)        if iTotalSize > 0:            iTotalSize = float(iTotalSize)            fResult = iTotalSize - fResult            i = 0        while fResult >= 1024:            fResult = fResult / 1024            i = i + 1        sRecalcSize = ' {:.2f}'.format(fResult)        sResult = (sRecalcSize, i)        return sResult    def script_saySize(self, gesture):        """say size"""        ObjResult = self._WinObjects()        oElement = ObjResult[0]        if oElement:            IsFolder = ObjResult[1]            if IsFolder == 2:                try:                    usedSize = oElement.TotalSize - oElement.FreeSpace                    colRecalc = self._RecalcSize(usedSize)                    sDimension = [" bytes", " KB", " MB", " GB", " TB"][colRecalc[1]]                    sRecalcSize = colRecalc[0]                    s_Info = sRecalcSize + sDimension                    ui.message(s_Info)                except:                    log.debug("No access to drive data")                    ui.message(_("No access to drive data"))                    return            elif IsFolder < 2:                try:                    iTmpSize = oElement.Size                    colRecalc = self._RecalcSize(iTmpSize)                    sDimension = [" bytes", " KB", " MB", " GB", " TB"][colRecalc[1]]                    sRecalcSize = colRecalc[0]                    s_Info = sRecalcSize + sDimension                    ui.message(s_Info)                except Exception as e:                    log.debug("No access to data")                    # Try alternative method for folder size calculation                    if IsFolder == 1:                        try:                            folderPath = oElement.Path                            total_size = 0                            for dirpath, dirnames, filenames in os.walk(folderPath):                                for f in filenames:                                    fp = os.path.join(dirpath, f)                                    try:                                        total_size += os.path.getsize(fp)                                    except OSError:                                        pass                            colRecalc = self._RecalcSize(total_size)                            sDimension = [" bytes", " KB", " MB", " GB", " TB"][colRecalc[1]]                            sRecalcSize = colRecalc[0]                            s_Info = sRecalcSize + sDimension                            ui.message(s_Info)                        except Exception as e:                            log.debug(f"Alternative folder size calculation failed: {e}")                            ui.message(_("No access to data"))                    else:                        ui.message(_("No access to data"))                    return    script_saySize.__doc__ = _("say size")    script_saySize.category = _("xPlorer")    script_saySize.gestures = ["kb(desktop):NVDA+shift+x"]    def script_copySelectedNames(self, gesture):        """Copy selected file and folder names to clipboard"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            gesture.send()            return                    try:            shellWindows = self.objShellApp.Windows()            foreground = api.getForegroundObject()            targetHwnd = foreground.windowHandle                        shellWindow = None            for i in range(shellWindows.Count):                w = shellWindows.Item(i)                if w.hwnd == targetHwnd:                    shellWindow = w                    break                                if not shellWindow:                ui.message(_("No Explorer window found"))                return                            selectedItems = []            if hasattr(shellWindow.document, 'SelectedItems'):                for i in range(shellWindow.document.SelectedItems().Count):                    item = shellWindow.document.SelectedItems().Item(i)                    selectedItems.append((item.Name, item.Path))                        if not selectedItems:                ui.message(_("No items selected"))                return                            # Separate folders and files            folders = []            files = []                        for name, path in selectedItems:                if os.path.isdir(path):                    folders.append(name)                else:                    files.append(name)                        # Sort folders and files alphabetically            folders.sort()            files.sort()                        # Combine with folders first, then files            sortedNames = folders + files                        # Join names with newline            namesText = "\n".join(sortedNames)                        # Copy to clipboard            if wx.TheClipboard.Open():                wx.TheClipboard.SetData(wx.TextDataObject(namesText))                wx.TheClipboard.Close()                if len(selectedItems) == 1:                    ui.message(_("Copied 1 item name to clipboard"))                else:                    ui.message(_("Copied {count} item names to clipboard").format(count=len(selectedItems)))            else:                ui.message(_("Could not open clipboard"))                        except Exception as e:            log.error(f"Error in copySelectedNames: {e}")            ui.message(_("Error copying names to clipboard"))            gesture.send()    script_copySelectedNames.__doc__ = _("Copy selected file and folder names to clipboard")    script_copySelectedNames.category = _("xPlorer")    script_copySelectedNames.gestures = ["kb(desktop):NVDA+shift+c"]    def _updateProgress(self, percent, message):        if self.progressDialog:            cont, skip = self.progressDialog.Update(percent, message)            # Play progress beep tone            if percent % 10 == 0:  # Beep every 10% progress                tones.beep(800 + percent * 2, 50)            if not cont:                self.cancelled = True    def _compressInBackground(self, sevenZipPath, selectedItems, callback):        """Compress files in background thread with progress"""        self.cancelled = False        try:            if len(selectedItems) == 1:                sourcePath = selectedItems[0]                if os.path.isfile(sourcePath):                    baseName = os.path.splitext(os.path.basename(sourcePath))[0]                else:                    baseName = os.path.basename(sourcePath)                zipPath = os.path.join(os.path.dirname(sourcePath), baseName + ".zip")            else:                folderPath = os.path.dirname(selectedItems[0])                folderName = os.path.basename(folderPath)                zipPath = os.path.join(folderPath, folderName + ".zip")                        counter = 1            originalZipPath = zipPath            while os.path.exists(zipPath):                name, ext = os.path.splitext(originalZipPath)                zipPath = f"{name} ({counter}){ext}"                counter += 1                            cmd = [sevenZipPath, "a", "-tzip", zipPath]            cmd.extend(selectedItems)                        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, creationflags=subprocess.CREATE_NO_WINDOW)                        last_percent = 0            msg = _("Compressing...")                        while True:                line = process.stdout.readline()                if not line:                    break                if '%' in line:                    try:                        percent_str = line.split('%')[0].strip()                        percent = int(percent_str)                        if percent > last_percent:                            last_percent = percent                            wx.CallAfter(self._updateProgress, percent, f"{msg} {percent}%")                    except ValueError:                        pass                if self.cancelled:                    process.terminate()                    break                        return_code = process.poll()                        if self.cancelled:                callback(False, _("Compression cancelled"))            elif return_code == 0:                callback(True, _("Compression completed {name}").format(name=os.path.basename(zipPath)))            else:                stderr = process.stderr.read() if process.stderr else ""                callback(False, _("compression failed: {error}").format(error=stderr))                        except Exception as e:            log.error(f"Error in background compression: {e}")            callback(False, _("Error in compression process: {error}").format(error=str(e)))    def _onCompressionComplete(self, success, message):        """Callback for compression completion"""        # Play completion beep tone        if success:            tones.beep(1000, 300)  # High tone for success        else:            tones.beep(500, 300)   # Low tone for failure                # Set focus back to the Explorer window if it still exists        if hasattr(self, 'lastExplorerHwnd') and self.lastExplorerHwnd and winUser.isWindow(self.lastExplorerHwnd):            try:                winUser.setForegroundWindow(self.lastExplorerHwnd)            except Exception as e:                log.error(f"Error setting foreground window: {e}")        else:            log.debug("Last Explorer window no longer exists or handle not available")        # Destroy progress dialog        if self.progressDialog:            try:                self.progressDialog.Destroy()            except:                pass            self.progressDialog = None    def script_compressZip(self, gesture):        """Compress selected items to ZIP"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            gesture.send()            return                    try:            shellWindows = self.objShellApp.Windows()            foreground = api.getForegroundObject()            targetHwnd = foreground.windowHandle                        shellWindow = None            for i in range(shellWindows.Count):                w = shellWindows.Item(i)                if w.hwnd == targetHwnd:                    shellWindow = w                    break                                if not shellWindow:                ui.message(_("No Explorer window found"))                return                            selectedItems = []            if hasattr(shellWindow.document, 'SelectedItems'):                for i in range(shellWindow.document.SelectedItems().Count):                    item = shellWindow.document.SelectedItems().Item(i)                    selectedItems.append(item.Path)                        if not selectedItems:                ui.message(_("No items selected"))                return                            # Store the current foreground window handle            self.lastExplorerHwnd = api.getForegroundObject().windowHandle                            sevenZipPath = self._find7zip()            style = wx.PD_APP_MODAL | wx.PD_CAN_ABORT | wx.PD_ELAPSED_TIME | wx.PD_REMAINING_TIME                        # Use only one compression method to prevent duplicate files            if sevenZipPath:                try:                    self.progressDialog = wx.ProgressDialog(_("Compressing files"), _("Starting..."), maximum=100, parent=gui.mainFrame, style=style)                    self.cancelled = False                                        if self.compressThread and self.compressThread.is_alive():                        self.compressThread.join(timeout=0.5)                                        self.compressThread = Thread(                        target=self._compressInBackground,                        args=(sevenZipPath, selectedItems, self._onCompressionComplete)                    )                    self.compressThread.daemon = True                    self.compressThread.start()                    return                except Exception as e:                    log.error(f"7zip background compression failed: {e}")                    ui.message(_("7-Zip compression failed, trying built-in method..."))                    # Continue to built-in method                                # If no 7zip or failed, use built-in with progress            self.progressDialog = wx.ProgressDialog(_("Compressing files"), _("Starting..."), maximum=100, parent=gui.mainFrame, style=style)            self.cancelled = False                        self.compressThread = Thread(                target=self._compressWithBuiltIn,                args=(selectedItems, self._onCompressionComplete)            )            self.compressThread.daemon = True            self.compressThread.start()                        except Exception as e:            log.error(f"Error in compressZip: {e}")            ui.message(_("Error compressing files"))            if self.progressDialog:                self.progressDialog.Destroy()                self.progressDialog = None    def _find7zip(self):        paths = [            os.path.join(os.environ.get("ProgramFiles", "C:\\Program Files"), "7-Zip", "7z.exe"),            os.path.join(os.environ.get("ProgramFiles(x86)", "C:\\Program Files (x86)"), "7-Zip", "7z.exe"),            os.path.join(os.environ.get("ProgramW6432", "C:\\Program Files"), "7-Zip", "7z.exe"),        ]                for path in paths:            if os.path.exists(path):                return path        return None    def _getTotalSize(self, selectedItems):        total = 0        for path in selectedItems:            if os.path.isfile(path):                try:                    total += os.path.getsize(path)                except:                    pass            elif os.path.isdir(path):                for root, dirs, files in os.walk(path):                    for f in files:                        fp = os.path.join(root, f)                        try:                            total += os.path.getsize(fp)                        except:                            pass        return total    def _compressWithBuiltIn(self, selectedItems, callback):        import zipfile        self.cancelled = False        try:            if len(selectedItems) == 1:                sourcePath = selectedItems[0]                if os.path.isfile(sourcePath):                    baseName = os.path.splitext(os.path.basename(sourcePath))[0]                else:                    baseName = os.path.basename(sourcePath)                zipPath = os.path.join(os.path.dirname(sourcePath), baseName + ".zip")            else:                folderPath = os.path.dirname(selectedItems[0])                folderName = os.path.basename(folderPath)                zipPath = os.path.join(folderPath, folderName + ".zip")                    counter = 1            originalZipPath = zipPath            while os.path.exists(zipPath):                name, ext = os.path.splitext(originalZipPath)                zipPath = f"{name} ({counter}){ext}"                counter += 1                        total_size = self._getTotalSize(selectedItems)            current_size = 0                        with zipfile.ZipFile(zipPath, 'w', zipfile.ZIP_DEFLATED) as zipf:                for item in selectedItems:                    if self.cancelled:                        break                    arcname = os.path.basename(item)                    if os.path.isfile(item):                        size = os.path.getsize(item)                        zipf.write(item, arcname)                        current_size += size                        percent = int(current_size * 100 / total_size) if total_size > 0 else 0                        wx.CallAfter(self._updateProgress, percent, _("Compressing: {percent}%").format(percent=percent))                    elif os.path.isdir(item):                        for root, dirs, files in os.walk(item):                            if self.cancelled:                                break                            for file in files:                                if self.cancelled:                                    break                                file_path = os.path.join(root, file)                                relative_path = os.path.relpath(file_path, os.path.dirname(item))                                size = os.path.getsize(file_path)                                zipf.write(file_path, os.path.join(arcname, relative_path))                                current_size += size                                percent = int(current_size * 100 / total_size) if total_size > 0 else 0                                wx.CallAfter(self._updateProgress, percent, _("Compressing: {percent}%").format(percent=percent))                        if self.cancelled:                os.remove(zipPath) if os.path.exists(zipPath) else None                wx.CallAfter(callback, False, _("Compression cancelled"))            else:                wx.CallAfter(self._updateProgress, 100, _("Completed"))                wx.CallAfter(callback, True, _("Compression completed {name}").format(name=os.path.basename(zipPath)))        except Exception as e:            log.error(f"Built-in compression failed: {e}")            wx.CallAfter(callback, False, _("Built-in compression failed: {error}").format(error=str(e)))    script_compressZip.__doc__ = _("Compress selected items to ZIP")    script_compressZip.category = _("xPlorer")    script_compressZip.gestures = ["kb(desktop):NVDA+shift+z"]    def script_renameFile(self, gesture):        """Rename selected file"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            gesture.send()            return                    try:            shellWindows = self.objShellApp.Windows()            foreground = api.getForegroundObject()            targetHwnd = foreground.windowHandle                        shellWindow = None            for i in range(shellWindows.Count):                w = shellWindows.Item(i)                if w.hwnd == targetHwnd:                    shellWindow = w                    break                                if not shellWindow:                ui.message(_("No Explorer window found"))                return                            selectedItems = []            if hasattr(shellWindow.document, 'SelectedItems'):                for i in range(shellWindow.document.SelectedItems().Count):                    item = shellWindow.document.SelectedItems().Item(i)                    selectedItems.append(item.Path)                        if not selectedItems:                ui.message(_("No items selected"))                return                            if len(selectedItems) > 1:                ui.message(_("Please select only one file"))                return                            filePath = selectedItems[0]                        if not os.path.isfile(filePath):                ui.message(_("Please select a file, not a folder"))                return                            fileName = os.path.basename(filePath)            dirName = os.path.dirname(filePath)                        wx.CallAfter(self._showRenameDialog, fileName, dirName, filePath)                        except Exception as e:            log.error(f"Error in renameFile: {e}")            ui.message(_("Error renaming file"))            gesture.send()    def _showRenameDialog(self, fileName, dirName, filePath):        try:            if self.renameDialog and self.renameDialog.IsShown():                self.renameDialog.Destroy()                            self.renameDialog = RenameDialog(gui.mainFrame, fileName)                        self.renameDialog.Raise()                        result = self.renameDialog.ShowModal()                        if result == wx.ID_OK and self.renameDialog.newName:                newPath = os.path.join(dirName, self.renameDialog.newName)                                if newPath == filePath:                    ui.message(_("File name not changed"))                    return                                    if os.path.exists(newPath):                    ui.message(_("A file with this name already exists"))                    return                                    try:                    os.rename(filePath, newPath)                    ui.message(_("File renamed to {name}").format(name=self.renameDialog.newName))                except Exception as e:                    log.error(f"Error renaming file: {e}")                    ui.message(_("Error renaming file"))                                self.renameDialog.Destroy()            self.renameDialog = None        except Exception as e:            log.error(f"Error showing rename dialog: {e}")            ui.message(_("Error opening rename dialog"))            if self.renameDialog:                try:                    self.renameDialog.Destroy()                except:                    pass                self.renameDialog = None    script_renameFile.__doc__ = _("Rename selected file")    script_renameFile.category = _("xPlorer")    script_renameFile.gestures = ["kb(desktop):NVDA+shift+f2"]    def chooseNVDAObjectOverlayClasses(self, obj, clsList):        self.manager.chooseNVDAObjectOverlayClasses(obj, clsList)    def event_gainFocus(self, obj, nextHandler):        self.manager.event_gainFocus(obj, nextHandler)    def event_focusEntered(self, obj, nextHandler):        self.manager.event_focusEntered(obj, nextHandler)    def event_foreground(self, obj, nextHandler):        self.manager.event_foreground(obj, nextHandler)    def event_UIA_elementSelected(self, obj, nextHandler):        self.manager.event_UIA_elementSelected(obj, nextHandler)