# __init__.py# Copyright (C) 2025 ['chai chaimee']# Licensed under GNU General Public License. See COPYING.txt for details.import globalPluginHandlerimport uiimport apiimport scriptHandlerfrom NVDAObjects import NVDAObjectfrom NVDAObjects.UIA import UIAfrom controlTypes import Role, Stateimport addonHandlerfrom comtypes.client import CreateObjectfrom logHandler import logimport guiimport wximport gui.guiHelperfrom .config import loadConfig, saveConfigfrom keyboardHandler import KeyboardInputGestureimport corefrom threading import Timer, Threadimport winUserimport osimport sysimport subprocessimport shutilimport tonesfrom .xPlorerManager import xPlorerSettingsPanel, ExplorerManageraddonHandler.initTranslation()class RenameDialog(wx.Dialog):    def __init__(self, parent, fileName):        super().__init__(parent, title="")        self.fileName = fileName        self.newName = None        self.InitUI()            def InitUI(self):        mainSizer = wx.BoxSizer(wx.VERTICAL)        sHelper = gui.guiHelper.BoxSizerHelper(self, orientation=wx.VERTICAL)                name, ext = os.path.splitext(self.fileName)                self.nameCtrl = sHelper.addItem(wx.TextCtrl(self, value=name))        self.nameCtrl.SelectAll()                if ext and ext.startswith('.'):            ext = ext[1:]        self.extCtrl = sHelper.addItem(wx.TextCtrl(self, value=ext))                btnSizer = self.CreateButtonSizer(wx.OK | wx.CANCEL)        sHelper.addItem(btnSizer, flag=wx.ALIGN_CENTER)                self.SetSizer(mainSizer)        mainSizer.Fit(self)                self.CentreOnScreen()        self.nameCtrl.SetFocus()                self.Bind(wx.EVT_BUTTON, self.OnOk, id=wx.ID_OK)        self.Bind(wx.EVT_BUTTON, self.OnCancel, id=wx.ID_CANCEL)        self.Bind(wx.EVT_TEXT_ENTER, self.OnOk)        self.Bind(wx.EVT_CLOSE, self.OnClose)            def OnOk(self, event):        name = self.nameCtrl.Value.strip()        ext = self.extCtrl.Value.strip()                if not name:            ui.message(_("File name cannot be empty"))            return                    if ext:            ext = "." + ext        self.newName = name + ext        self.EndModal(wx.ID_OK)            def OnCancel(self, event):        self.EndModal(wx.ID_CANCEL)            def OnClose(self, event):        self.EndModal(wx.ID_CANCEL)class GlobalPlugin(globalPluginHandler.GlobalPlugin):    scriptCategory = _("xPlorer")        def __init__(self):        super().__init__()        self.objShellApp = CreateObject("Shell.Application")        self.objFSO = CreateObject("scripting.FileSystemObject")        gui.settingsDialogs.NVDASettingsDialog.categoryClasses.append(xPlorerSettingsPanel)        self.manager = ExplorerManager(self)        self.renameDialog = None        self.progressDialog = None        self.compressThread = None        self.cancelled = False        self.lastExplorerHwnd = None        self.lastExplorerDocument = None                # Add tools directory to Python path for striprtf module        tools_dir = os.path.join(os.path.dirname(__file__), "tools")        if os.path.exists(tools_dir) and tools_dir not in sys.path:            sys.path.insert(0, tools_dir)    def terminate(self):        super().terminate()        gui.settingsDialogs.NVDASettingsDialog.categoryClasses.remove(xPlorerSettingsPanel)        if self.renameDialog:            try:                self.renameDialog.Destroy()            except:                pass        if self.progressDialog:            try:                self.progressDialog.Destroy()            except:                pass        if self.compressThread and self.compressThread.is_alive():            self.compressThread.join(timeout=1.0)    def _getActiveExplorerWindow(self):        """Get the active Explorer window with focus"""        try:            shellWindows = self.objShellApp.Windows()            foreground = api.getForegroundObject()            targetHwnd = foreground.windowHandle                        # First try to find exact hwnd match with visible Explorer window            for i in range(shellWindows.Count):                w = shellWindows.Item(i)                try:                    if w.hwnd == targetHwnd and w.Visible and w.Name == "File Explorer":                        return w                except:                    pass                        # If not found, try any matching hwnd            for i in range(shellWindows.Count):                w = shellWindows.Item(i)                try:                    if w.hwnd == targetHwnd:                        return w                except:                    pass                        # If still not found, try any visible Explorer window            for i in range(shellWindows.Count):                w = shellWindows.Item(i)                try:                    if w.Visible and w.Name == "File Explorer":                        return w                except:                    pass                        return None        except Exception as e:            log.error(f"Error getting active Explorer window: {e}")            return None    def _getSelectedItems(self):        """Get selected items from active Explorer window"""        try:            # Try to get selected items from the focused object first            focus = api.getFocusObject()            if focus and focus.appModule.appName == "explorer":                # For Windows 11 File Explorer with tabs, we need to get the document                # from the focused object's window handle                shellWindow = self._getActiveExplorerWindow()                if not shellWindow:                    return None, None                                    # Check if we've switched to a different document (different tab)                currentDocument = None                try:                    currentDocument = shellWindow.document                    if self.lastExplorerDocument != currentDocument:                        self.lastExplorerDocument = currentDocument                        log.debug(f"Switched to new Explorer document/tab")                except:                    pass                                    selectedItems = []                if hasattr(shellWindow.document, 'SelectedItems'):                    selectedItemsCount = shellWindow.document.SelectedItems().Count                    for i in range(selectedItemsCount):                        item = shellWindow.document.SelectedItems().Item(i)                        selectedItems.append((item.Name, item.Path))                                return selectedItems, shellWindow            return None, None        except Exception as e:            log.error(f"Error getting selected items: {e}")            return None, None    def _RecalcSize(self, iResult, iTotalSize=0):        fResult = float(iResult)        if iTotalSize > 0:            iTotalSize = float(iTotalSize)            fResult = iTotalSize - fResult            i = 0        while fResult >= 1024:            fResult = fResult / 1024            i = i + 1        sRecalcSize = ' {:.2f}'.format(fResult)        sResult = (sRecalcSize, i)        return sResult    def _saySize(self):        """say size for single or multiple selected items"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            return                    selectedItems, shellWindow = self._getSelectedItems()        if not selectedItems:            ui.message(_("No items selected"))            return                    totalSize = 0        isDrive = False                for name, path in selectedItems:            if self.objFSO.FileExists(path):                try:                    totalSize += self.objFSO.GetFile(path).Size                except:                    pass            elif self.objFSO.DriveExists(path):                isDrive = True                try:                    drive = self.objFSO.GetDrive(path)                    usedSize = drive.TotalSize - drive.FreeSpace                    totalSize += usedSize  # For drives, we show used space                except:                    pass            elif self.objFSO.FolderExists(path):                try:                    folder = self.objFSO.GetFolder(path)                    # For folders, we need to calculate the size recursively                    for root, dirs, files in os.walk(path):                        for f in files:                            fp = os.path.join(root, f)                            try:                                totalSize += os.path.getsize(fp)                            except:                                pass                except:                    pass                if totalSize == 0 and not isDrive:            ui.message(_("No access to size data"))            return                    colRecalc = self._RecalcSize(totalSize)                    sDimension = [" bytes", " KB", " MB", " GB", " TB"][colRecalc[1]]        sRecalcSize = colRecalc[0]        s_Info = sRecalcSize + sDimension                if len(selectedItems) > 1:            s_Info = _("{count} items {size}").format(count=len(selectedItems), size=s_Info)                    ui.message(s_Info)    def script_saySize(self, gesture):        self._saySize()    script_saySize.__doc__ = _("say size")    script_saySize.category = _("xPlorer")    script_saySize.gestures = ["kb(desktop):NVDA+shift+x"]    def _copySelectedNames(self):        """Copy selected file and folder names to clipboard"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            return                    try:            selectedItems, shellWindow = self._getSelectedItems()            if not selectedItems:                ui.message(_("No items selected"))                return                            # Separate folders and files            folders = []            files = []                        for name, path in selectedItems:                if os.path.isdir(path):                    folders.append(name)                else:                    files.append(name)                        # Sort folders and files alphabetically            folders.sort()            files.sort()                        # Combine with folders first, then files            sortedNames = folders + files                        # Join names with newline            namesText = "\n".join(sortedNames)                        # Copy to clipboard            if wx.TheClipboard.Open():                wx.TheClipboard.SetData(wx.TextDataObject(namesText))                wx.TheClipboard.Close()                if len(selectedItems) == 1:                    ui.message(_("Copied 1 item name to clipboard"))                else:                    ui.message(_("Copied {count} item names to clipboard").format(count=len(selectedItems)))            else:                ui.message(_("Could not open clipboard"))                        except Exception as e:            log.error(f"Error in copySelectedNames: {e}")            ui.message(_("Error copying names to clipboard"))    def script_copySelectedNames(self, gesture):        self._copySelectedNames()    script_copySelectedNames.__doc__ = _("Copy selected file and folder names to clipboard")    script_copySelectedNames.category = _("xPlorer")    script_copySelectedNames.gestures = ["kb(desktop):NVDA+shift+c"]    def _copyFileContent(self):        """Copy content of selected text file(s) to clipboard"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            return                    try:            selectedItems, shellWindow = self._getSelectedItems()            if not selectedItems:                ui.message(_("No items selected"))                return                            # Check if any selected item is a folder            for name, path in selectedItems:                if os.path.isdir(path):                    ui.message(_("Cannot copy content of folders, please select files only"))                    return                                # Define text file extensions including .rtf            textExtensions = ['.txt', '.py', '.js', '.html', '.css', '.xml', '.json',                             '.csv', '.md', '.ini', '.conf', '.cfg', '.java', '.cpp',                             '.c', '.h', '.php', '.rb', '.pl', '.sh', '.bat', '.ps1', '.rtf']                        # Filter text files only            textFiles = []            for name, path in selectedItems:                fileExt = os.path.splitext(path)[1].lower()                if fileExt in textExtensions:                    textFiles.append(path)                else:                    log.debug(f"Skipping non-text file: {name}")                        if not textFiles:                ui.message(_("No text files selected"))                return                            # Set total size limit (15 MB)            totalSize = 0            for filePath in textFiles:                try:                    totalSize += os.path.getsize(filePath)                except:                    pass                                if totalSize > 15 * 1024 * 1024:                ui.message(_("Total file size is too large to copy content"))                return                            # Read and combine file contents            combinedContent = ""            filesProcessed = 0                        for filePath in textFiles:                try:                    fileExt = os.path.splitext(filePath)[1].lower()                                        if fileExt == '.rtf':                        # Handle RTF files with striprtf                        try:                            from striprtf.striprtf import rtf_to_text                            with open(filePath, 'r', encoding='utf-8', errors='ignore') as f:                                rtf_content = f.read()                            content = rtf_to_text(rtf_content)                        except ImportError:                            log.error("striprtf module not available for RTF processing")                            content = _("[RTF content - striprtf module not available]")                        except Exception as e:                            log.error(f"Error processing RTF file {filePath}: {e}")                            content = _("[Error processing RTF file]")                    else:                        # Handle other text files                        with open(filePath, 'r', encoding='utf-8') as f:                            content = f.read()                                        # Add content without file headers                    if filesProcessed > 0:                        combinedContent += "\n\n"                    combinedContent += content                                        filesProcessed += 1                                    except UnicodeDecodeError:                    # Try with different encoding if UTF-8 fails                    try:                        with open(filePath, 'r', encoding='latin-1') as f:                            content = f.read()                                                if filesProcessed > 0:                            combinedContent += "\n\n"                        combinedContent += content                                                filesProcessed += 1                    except:                        log.error(f"Failed to read file: {filePath}")                except Exception as e:                    log.error(f"Error reading file {filePath}: {e}")                        if not combinedContent.strip():                ui.message(_("No content could be read from selected files"))                return                            # Copy to clipboard            if wx.TheClipboard.Open():                wx.TheClipboard.SetData(wx.TextDataObject(combinedContent))                wx.TheClipboard.Close()                                if filesProcessed == 1:                    ui.message(_("Content from 1 file copied to clipboard"))                else:                    ui.message(_("Content from {count} files copied to clipboard").format(count=filesProcessed))            else:                ui.message(_("Could not open clipboard"))                        except Exception as e:            log.error(f"Error in copyFileContent: {e}")            ui.message(_("Error copying file content"))    def script_copyFileContent(self, gesture):        self._copyFileContent()    script_copyFileContent.__doc__ = _("Copy content of selected text file(s) to clipboard")    script_copyFileContent.category = _("xPlorer")    script_copyFileContent.gestures = ["kb(desktop):NVDA+shift+v"]    def _updateProgress(self, percent, message):        if self.progressDialog:            cont, skip = self.progressDialog.Update(percent, message)            # Play progress beep tone            if percent % 10 == 0:  # Beep every 10% progress                tones.beep(800 + percent * 2, 50)            if not cont:                self.cancelled = True    def _compressInBackground(self, sevenZipPath, selectedItems, callback):        """Compress files in background thread with progress"""        self.cancelled = False        try:            if len(selectedItems) == 1:                sourcePath = selectedItems[0]                if os.path.isfile(sourcePath):                    baseName = os.path.splitext(os.path.basename(sourcePath))[0]                else:                    baseName = os.path.basename(sourcePath)                zipPath = os.path.join(os.path.dirname(sourcePath), baseName + ".zip")            else:                folderPath = os.path.dirname(selectedItems[0])                folderName = os.path.basename(folderPath)                zipPath = os.path.join(folderPath, folderName + ".zip")                        counter = 1            originalZipPath = zipPath            while os.path.exists(zipPath):                name, ext = os.path.splitext(originalZipPath)                zipPath = f"{name} ({counter}){ext}"                counter += 1                            cmd = [sevenZipPath, "a", "-tzip", zipPath]            cmd.extend(selectedItems)                        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, creationflags=subprocess.CREATE_NO_WINDOW)                        last_percent = 0            msg = _("Compressing...")                        while True:                line = process.stdout.readline()                if not line:                    break                if '%' in line:                    try:                        percent_str = line.split('%')[0].strip()                        percent = int(percent_str)                        if percent > last_percent:                            last_percent = percent                            wx.CallAfter(self._updateProgress, percent, f"{msg} {percent}%")                    except ValueError:                        pass                if self.cancelled:                    process.terminate()                    break                        return_code = process.poll()                        if self.cancelled:                callback(False, _("Compression cancelled"))            elif return_code == 0:                callback(True, _("Compression completed {name}").format(name=os.path.basename(zipPath)))            else:                stderr = process.stderr.read() if process.stderr else ""                callback(False, _("compression failed: {error}").format(error=stderr))                        except Exception as e:            log.error(f"Error in background compression: {e}")            callback(False, _("Error in compression process: {error}").format(error=str(e)))    def _onCompressionComplete(self, success, message):        """Callback for compression completion"""        # Play completion beep tone        if success:            tones.beep(1000, 300)  # High tone for success        else:            tones.beep(500, 300)   # Low tone for failure                # Set focus back to the Explorer window if it still exists        if hasattr(self, 'lastExplorerHwnd') and self.lastExplorerHwnd and winUser.isWindow(self.lastExplorerHwnd):            try:                winUser.setForegroundWindow(self.lastExplorerHwnd)            except Exception as e:                log.error(f"Error setting foreground window: {e}")        else:            log.debug("Last Explorer window no longer exists or handle not available")        # Destroy progress dialog        if self.progressDialog:            try:                self.progressDialog.Destroy()            except:                pass            self.progressDialog = None    def _compressZip(self):        """Compress selected items to ZIP"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            return                    try:            selectedItems, shellWindow = self._getSelectedItems()            if not selectedItems:                ui.message(_("No items selected"))                return                            # Get paths only            paths = [path for name, path in selectedItems]                            # Store the current foreground window handle            self.lastExplorerHwnd = api.getForegroundObject().windowHandle                            sevenZipPath = self._find7zip()            style = wx.PD_APP_MODAL | wx.PD_CAN_ABORT | wx.PD_ELAPSED_TIME | wx.PD_REMAINING_TIME                        # Use only one compression method to prevent duplicate files            if sevenZipPath:                try:                    self.progressDialog = wx.ProgressDialog(_("Compressing files"), _("Starting..."), maximum=100, parent=gui.mainFrame, style=style)                    self.cancelled = False                                        if self.compressThread and self.compressThread.is_alive():                        self.compressThread.join(timeout=0.5)                                        self.compressThread = Thread(                        target=self._compressInBackground,                        args=(sevenZipPath, paths, self._onCompressionComplete)                    )                    self.compressThread.daemon = True                    self.compressThread.start()                    return                except Exception as e:                    log.error(f"7zip background compression failed: {e}")                    ui.message(_("7-Zip compression failed, trying built-in method..."))                    # Continue to built-in method                                # If no 7zip or failed, use built-in with progress            self.progressDialog = wx.ProgressDialog(_("Compressing files"), _("Starting..."), maximum=100, parent=gui.mainFrame, style=style)            self.cancelled = False                        self.compressThread = Thread(                target=self._compressWithBuiltIn,                args=(paths, self._onCompressionComplete)            )            self.compressThread.daemon = True            self.compressThread.start()                        except Exception as e:            log.error(f"Error in compressZip: {e}")            ui.message(_("Error compressing files"))            if self.progressDialog:                self.progressDialog.Destroy()                self.progressDialog = None    def script_compressZip(self, gesture):        self._compressZip()    def _find7zip(self):        paths = [            os.path.join(os.environ.get("ProgramFiles", "C:\\Program Files"), "7-Zip", "7z.exe"),            os.path.join(os.environ.get("ProgramFiles(x86)", "C:\\Program Files (x86)"), "7-Zip", "7z.exe"),            os.path.join(os.environ.get("ProgramW6432", "C:\\Program Files"), "7-Zip", "7z.exe"),        ]                for path in paths:            if os.path.exists(path):                return path        return None    def _getTotalSize(self, selectedItems):        total = 0        for path in selectedItems:            if os.path.isfile(path):                try:                    total += os.path.getsize(path)                except:                    pass            elif os.path.isdir(path):                for root, dirs, files in os.walk(path):                    for f in files:                        fp = os.path.join(root, f)                        try:                            total += os.path.getsize(fp)                        except:                            pass        return total    def _compressWithBuiltIn(self, selectedItems, callback):        import zipfile        self.cancelled = False        try:            if len(selectedItems) == 1:                sourcePath = selectedItems[0]                if os.path.isfile(sourcePath):                    baseName = os.path.splitext(os.path.basename(sourcePath))[0]                else:                    baseName = os.path.basename(sourcePath)                zipPath = os.path.join(os.path.dirname(sourcePath), baseName + ".zip")            else:                folderPath = os.path.dirname(selectedItems[0])                folderName = os.path.basename(folderPath)                zipPath = os.path.join(folderPath, folderName + ".zip")                    counter = 1            originalZipPath = zipPath            while os.path.exists(zipPath):                name, ext = os.path.splitext(originalZipPath)                zipPath = f"{name} ({counter}){ext}"                counter += 1                        total_size = self._getTotalSize(selectedItems)            current_size = 0                        with zipfile.ZipFile(zipPath, 'w', zipfile.ZIP_DEFLATED) as zipf:                for item in selectedItems:                    if self.cancelled:                        break                    arcname = os.path.basename(item)                    if os.path.isfile(item):                        size = os.path.getsize(item)                        zipf.write(item, arcname)                        current_size += size                        percent = int(current_size * 100 / total_size) if total_size > 0 else 0                        wx.CallAfter(self._updateProgress, percent, _("Compressing: {percent}%").format(percent=percent))                    elif os.path.isdir(item):                        for root, dirs, files in os.walk(item):                            if self.cancelled:                                break                            for file in files:                                if self.cancelled:                                    break                                file_path = os.path.join(root, file)                                relative_path = os.path.relpath(file_path, os.path.dirname(item))                                size = os.path.getsize(file_path)                                zipf.write(file_path, os.path.join(arcname, relative_path))                                current_size += size                                percent = int(current_size * 100 / total_size) if total_size > 0 else 0                                wx.CallAfter(self._updateProgress, percent, _("Compressing: {percent}%").format(percent=percent))                        if self.cancelled:                os.remove(zipPath) if os.path.exists(zipPath) else None                wx.CallAfter(callback, False, _("Compression cancelled"))            else:                wx.CallAfter(self._updateProgress, 100, _("Completed"))                wx.CallAfter(callback, True, _("Compression completed {name}").format(name=os.path.basename(zipPath)))        except Exception as e:            log.error(f"Built-in compression failed: {e}")            wx.CallAfter(callback, False, _("Built-in compression failed: {error}").format(error=str(e)))    script_compressZip.__doc__ = _("Compress selected items to ZIP")    script_compressZip.category = _("xPlorer")    script_compressZip.gestures = ["kb(desktop):NVDA+shift+z"]    def _renameFile(self):        """Rename selected file"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            return                    try:            selectedItems, shellWindow = self._getSelectedItems()            if not selectedItems:                ui.message(_("No items selected"))                return                            if len(selectedItems) > 1:                ui.message(_("Please select only one file"))                return                            filePath = selectedItems[0][1]                        if not os.path.isfile(filePath):                ui.message(_("Please select a file, not a folder"))                return                            fileName = os.path.basename(filePath)            dirName = os.path.dirname(filePath)                        wx.CallAfter(self._showRenameDialog, fileName, dirName, filePath)                        except Exception as e:            log.error(f"Error in renameFile: {e}")            ui.message(_("Error renaming file"))    def script_renameFile(self, gesture):        self._renameFile()    def _showRenameDialog(self, fileName, dirName, filePath):        try:            if self.renameDialog and self.renameDialog.IsShown():                self.renameDialog.Destroy()                            self.renameDialog = RenameDialog(gui.mainFrame, fileName)                        self.renameDialog.Raise()                        result = self.renameDialog.ShowModal()                        if result == wx.ID_OK and self.renameDialog.newName:                newPath = os.path.join(dirName, self.renameDialog.newName)                                if newPath == filePath:                    ui.message(_("File name not changed"))                    return                                    if os.path.exists(newPath):                    ui.message(_("A file with this name already exists"))                    return                                    try:                    os.rename(filePath, newPath)                    ui.message(_("File renamed to {name}").format(name=self.renameDialog.newName))                except Exception as e:                    log.error(f"Error renaming file: {e}")                    ui.message(_("Error renaming file"))                                self.renameDialog.Destroy()            self.renameDialog = None        except Exception as e:            log.error(f"Error showing rename dialog: {e}")            ui.message(_("Error opening rename dialog"))            if self.renameDialog:                try:                    self.renameDialog.Destroy()                except:                    pass                self.renameDialog = None    script_renameFile.__doc__ = _("Rename selected file")    script_renameFile.category = _("xPlorer")    script_renameFile.gestures = ["kb(desktop):NVDA+shift+f2"]    def _invertSelection(self):        """Invert selection in File Explorer"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            return                    try:            shellWindow = self._getActiveExplorerWindow()            if not shellWindow:                ui.message(_("No active File Explorer window found"))                return                            # Get the document (folder view)            document = shellWindow.document                        # Get all items in the current view            allItems = []            selectedItems = []                        # Try to get items from the folder view            if hasattr(document, 'Folder'):                folder = document.Folder                if hasattr(folder, 'Items'):                    items = folder.Items()                    for i in range(items.Count):                        item = items.Item(i)                        allItems.append(item)                        # Get currently selected items            if hasattr(document, 'SelectedItems'):                selectedItemsCount = document.SelectedItems().Count                for i in range(selectedItemsCount):                    item = document.SelectedItems().Item(i)                    selectedItems.append(item.Path)                        # Create sets for comparison            allPaths = set(item.Path for item in allItems)            selectedPaths = set(selectedItems)                        # Calculate inverted selection            invertedPaths = allPaths - selectedPaths                        # Clear current selection            if hasattr(document, 'ClearSelection'):                document.ClearSelection()            else:                # Alternative method to clear selection using keyboard simulation                api.getFocusObject().typeKeys("ctrl+shift+space")                        # Select the inverted items            for item in allItems:                if item.Path in invertedPaths:                    try:                        # Select the item                        if hasattr(item, 'InvokeVerb'):                            item.InvokeVerb("select")                    except Exception as e:                        log.error(f"Error selecting item {item.Name}: {e}")                        # Report the result            totalCount = len(allPaths)            selectedCount = len(selectedPaths)            invertedCount = len(invertedPaths)                        ui.message(_("Inverted selection: {inverted} of {total} items selected").format(                inverted=invertedCount, total=totalCount))                        except Exception as e:            log.error(f"Error in invertSelection: {e}")            ui.message(_("Error inverting selection"))    def script_invertSelection(self, gesture):        self._invertSelection()    script_invertSelection.__doc__ = _("Invert selection in File Explorer")    script_invertSelection.category = _("xPlorer")    script_invertSelection.gestures = ["kb(desktop):NVDA+shift+i"]    def _createContextMenu(self):        """Create and return the context menu"""        menu = wx.Menu()                # Add menu items        compress_item = menu.Append(wx.ID_ANY, _("Compress zip"))        copy_content_item = menu.Append(wx.ID_ANY, _("Copy content"))        copy_names_item = menu.Append(wx.ID_ANY, _("Copy selected file and folder names"))        invert_selection_item = menu.Append(wx.ID_ANY, _("Invert selection"))        rename_item = menu.Append(wx.ID_ANY, _("Rename selected file"))        say_size_item = menu.Append(wx.ID_ANY, _("say size"))                # Bind events to menu items        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._compressZip), compress_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._copyFileContent), copy_content_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._copySelectedNames), copy_names_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._invertSelection), invert_selection_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._renameFile), rename_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._saySize), say_size_item)                return menu    def _showContextMenu(self):        """Show the context menu asynchronously to avoid blocking"""        def show_menu():            try:                # Check if we're in File Explorer                focus = api.getFocusObject()                if not focus or focus.appModule.appName != "explorer":                    ui.message(_("Not in File Explorer"))                    return                                # Create the menu                menu = self._createContextMenu()                                # Create a temporary frame for the menu                frame = wx.Frame(gui.mainFrame, -1, "", pos=(0, 0), size=(0, 0))                try:                    frame.Show()                    frame.Raise()                                        # Show the menu and clean up                    frame.PopupMenu(menu)                except Exception as e:                    log.error(f"Error displaying popup menu: {e}")                    ui.message(_("Error displaying context menu"))                finally:                    try:                        menu.Destroy()                    except:                        pass                    try:                        frame.Destroy()                    except:                        pass                            except Exception as e:                log.error(f"Error in showContextMenu: {e}")                ui.message(_("Error opening context menu"))                # Run menu display asynchronously        wx.CallAfter(show_menu)    def script_openXPlorerContextMenu(self, gesture):        """Open xPlorer context menu"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("This command is only available in File Explorer."))            return                    self._showContextMenu()    script_openXPlorerContextMenu.__doc__ = _("Open xPlorer context menu")    script_openXPlorerContextMenu.category = _("xPlorer")    script_openXPlorerContextMenu.gestures = ["kb(desktop):NVDA+shift+a"]    def chooseNVDAObjectOverlayClasses(self, obj, clsList):        self.manager.chooseNVDAObjectOverlayClasses(obj, clsList)    def event_gainFocus(self, obj, nextHandler):        self.manager.event_gainFocus(obj, nextHandler)    def event_focusEntered(self, obj, nextHandler):        self.manager.event_focusEntered(obj, nextHandler)    def event_foreground(self, obj, nextHandler):        self.manager.event_foreground(obj, nextHandler)    def event_UIA_elementSelected(self, obj, nextHandler):        self.manager.event_UIA_elementSelected(obj, nextHandler)