# __init__.pyimport globalPluginHandlerimport uiimport apiimport scriptHandlerfrom NVDAObjects import NVDAObjectfrom NVDAObjects.UIA import UIAfrom controlTypes import Role, Stateimport addonHandlerfrom comtypes.client import CreateObjectfrom logHandler import logimport guiimport wximport gui.guiHelperfrom .config import loadConfig, saveConfigfrom keyboardHandler import KeyboardInputGestureimport corefrom threading import Timer, Threadimport winUserimport osimport sysimport subprocessimport shutilimport tonesimport urllib.parseimport timefrom .xPlorerManager import xPlorerSettingsPanel, ExplorerManagerfrom .fileOperations import RenameDialog, FileOperationsfrom .compressionManager import CompressionManagerfrom .clipboardManager import ClipboardManagerfrom .selectionManager import SelectionManagerfrom .robocopyManager import RobocopyManagerfrom .txt2folder import TxtToFolderaddonHandler.initTranslation()# Global variables for double-tap detection_last_tap_time = 0_tap_count = 0_double_tap_threshold = 0.3  # secondsclass GlobalPlugin(globalPluginHandler.GlobalPlugin):    scriptCategory = _("xPlorer")        def __init__(self):        super().__init__()        self.objShellApp = CreateObject("Shell.Application")        self.objFSO = CreateObject("scripting.FileSystemObject")        gui.settingsDialogs.NVDASettingsDialog.categoryClasses.append(xPlorerSettingsPanel)        self.manager = ExplorerManager(self)        self.fileOps = FileOperations(self)        self.compression = CompressionManager(self)        self.clipboard = ClipboardManager(self)        self.selection = SelectionManager(self)        self.robocopy = RobocopyManager(self)        self.txt2folder = TxtToFolder(self)                # Lazy import for striprtf to avoid startup delay        self._striprtf_available = None        tools_dir = os.path.join(os.path.dirname(__file__), "tools")        if os.path.exists(tools_dir) and tools_dir not in sys.path:            sys.path.insert(0, tools_dir)    def terminate(self):        super().terminate()        gui.settingsDialogs.NVDASettingsDialog.categoryClasses.remove(xPlorerSettingsPanel)        self.fileOps.cleanup()        self.compression.cleanup()        self.selection.cleanup()        self.robocopy.cleanup()    def _getStriprtfModule(self):        """Lazy import striprtf module to avoid startup delay"""        if self._striprtf_available is None:            try:                from striprtf.striprtf import rtf_to_text                self._striprtf_available = rtf_to_text                log.info("striprtf module loaded successfully")            except ImportError:                log.warning("striprtf module not available")                self._striprtf_available = False            except Exception as e:                log.error(f"Error loading striprtf: {e}")                self._striprtf_available = False        return self._striprtf_available    def _getActiveExplorerWindow(self):        """Get the active Explorer window with focus"""        try:            shellWindows = self.objShellApp.Windows()            foreground = api.getForegroundObject()            targetHwnd = foreground.windowHandle                        for i in range(shellWindows.Count):                w = shellWindows.Item(i)                try:                    if w.hwnd == targetHwnd and w.Visible and w.Name == "File Explorer":                        return w                except:                    pass                        for i in range(shellWindows.Count):                w = shellWindows.Item(i)                try:                    if w.hwnd == targetHwnd:                        return w                except:                    pass                        for i in range(shellWindows.Count):                w = shellWindows.Item(i)                try:                    if w.Visible and w.Name == "File Explorer":                        return w                except:                    pass                        return None        except Exception as e:            log.error(f"Error getting active Explorer window: {e}")            return None    def _getSelectedItems(self):        """Get selected items from active Explorer window"""        try:            focus = api.getFocusObject()            if focus and focus.appModule.appName == "explorer":                shellWindow = self._getActiveExplorerWindow()                if not shellWindow:                    return None, None                                    currentDocument = None                try:                    currentDocument = shellWindow.document                    if self.manager.lastExplorerDocument != currentDocument:                        self.manager.lastExplorerDocument = currentDocument                except:                    pass                                    selectedItems = []                if hasattr(shellWindow.document, 'SelectedItems'):                    selectedItemsCount = shellWindow.document.SelectedItems().Count                    for i in range(selectedItemsCount):                        item = shellWindow.document.SelectedItems().Item(i)                        selectedItems.append((item.Name, item.Path))                                return selectedItems, shellWindow            return None, None        except Exception as e:            log.error(f"Error getting selected items: {e}")            return None, None    def _executeWithSilence(self, func):        """Execute function with all announcements silenced"""        import speech        speech.cancelSpeech()        self.manager.suppressAllAnnouncements = True        try:            func()        finally:            core.callLater(1000, lambda: setattr(self.manager, 'suppressAllAnnouncements', False))    def _getCurrentPath(self):        """Get current path from address bar"""        try:            shell_win = self._getActiveExplorerWindow()            if shell_win:                try:                    loc = shell_win.LocationURL                    if loc and loc.startswith("file:///"):                        path = urllib.parse.unquote(loc[8:].replace("/", "\\"))                        if os.path.exists(path):                            return path                except:                    pass            hwnd = winUser.getForegroundWindow()            title = winUser.getWindowText(hwnd)            if " - File Explorer" in title:                p = title.replace(" - File Explorer", "")                if os.path.exists(p):                    return p            return None        except:            return None    def _copyAddressBar(self):        """Copy address bar path to clipboard"""        path = self._getCurrentPath()        if path:            if wx.TheClipboard.Open():                wx.TheClipboard.SetData(wx.TextDataObject(path))                wx.TheClipboard.Close()                ui.message(_("Copied: {path}").format(path=path))            else:                ui.message(_("Could not open clipboard"))        else:            ui.message(_("Unable to get current path"))    def script_copySelectedNamesOrAddressBar(self, gesture):        """Handle copy selected names (single tap) or copy address bar (double tap)"""        global _last_tap_time, _tap_count                current_time = time.time()                # Reset tap count if too much time has passed        if current_time - _last_tap_time > _double_tap_threshold:            _tap_count = 0                _tap_count += 1        _last_tap_time = current_time                # Wait to see if this is a double tap        if _tap_count == 1:            # Single tap - wait to see if it becomes double            wx.CallLater(int(_double_tap_threshold * 1000), self._processCopyTap)        elif _tap_count >= 2:            # Double tap - process immediately            self._processCopyTap()    def _processCopyTap(self):        """Process tap action based on tap count"""        global _tap_count                if _tap_count == 1:            # Single tap - copy selected names            self._executeWithSilence(self.clipboard.copySelectedNames)        elif _tap_count >= 2:            # Double tap - copy address bar            self._executeWithSilence(self._copyAddressBar)                _tap_count = 0    script_copySelectedNamesOrAddressBar.__doc__ = _("Copy selected names (single tap) or copy address bar (double tap)")    script_copySelectedNamesOrAddressBar.category = _("xPlorer")    script_copySelectedNamesOrAddressBar.gestures = ["kb(desktop):NVDA+shift+c"]    def _saySize(self):        self._executeWithSilence(self.fileOps.saySize)    def script_saySize(self, gesture):        self._saySize()    script_saySize.__doc__ = _("say size")    script_saySize.category = _("xPlorer")    script_saySize.gestures = ["kb(desktop):NVDA+shift+x"]    def _copyFileContent(self):        self._executeWithSilence(self.clipboard.copyFileContent)    def script_copyFileContent(self, gesture):        self._copyFileContent()    script_copyFileContent.__doc__ = _("Copy content of selected text file(s) to clipboard")    script_copyFileContent.category = _("xPlorer")    script_copyFileContent.gestures = ["kb(desktop):NVDA+shift+v"]    def _compressZip(self):        self._executeWithSilence(self.compression.compressZip)    def script_compressZip(self, gesture):        self._compressZip()    script_compressZip.__doc__ = _("Compress selected items to ZIP")    script_compressZip.category = _("xPlorer")    script_compressZip.gestures = ["kb(desktop):NVDA+shift+z"]    def _renameFile(self):        self._executeWithSilence(self.fileOps.renameFile)    def script_renameFile(self, gesture):        self._renameFile()    script_renameFile.__doc__ = _("Rename selected file")    script_renameFile.category = _("xPlorer")    script_renameFile.gestures = ["kb(desktop):NVDA+shift+f2"]    def script_invertSelection(self, gesture):        self._executeWithSilence(self.selection.invertSelection)    script_invertSelection.__doc__ = _("Invert selection in File Explorer")    script_invertSelection.category = _("xPlorer")    script_invertSelection.gestures = ["kb(desktop):NVDA+shift+i"]    def _createContextMenu(self):        """Create and return the context menu"""        menu = wx.Menu()                # Add menu items in alphabetical order        compress_item = menu.Append(wx.ID_ANY, _("Compress zip"))        copy_content_item = menu.Append(wx.ID_ANY, _("Copy content"))        copy_names_item = menu.Append(wx.ID_ANY, _("Copy selected file and folder names"))        invert_selection_item = menu.Append(wx.ID_ANY, _("Invert selection"))        rename_item = menu.Append(wx.ID_ANY, _("Rename selected file"))                # Create Robocopy submenu        robocopy_menu = wx.Menu()        robocopy_item = menu.AppendSubMenu(robocopy_menu, _("Robocopy"))                # Add items to Robocopy submenu        copy_item = robocopy_menu.Append(wx.ID_ANY, _("copy"))        move_item = robocopy_menu.Append(wx.ID_ANY, _("move"))        paste_item = robocopy_menu.Append(wx.ID_ANY, _("paste"))        robocopy_menu.AppendSeparator()        mirror_item = robocopy_menu.Append(wx.ID_ANY, _("mirror Backup"))                # Add TXT to Folder menu item        txt_to_folder_item = menu.Append(wx.ID_ANY, _("TXT to Folder"))                # Add say size after TXT to Folder        say_size_item = menu.Append(wx.ID_ANY, _("say size"))                # Add Copy address bar menu item        copy_address_item = menu.Append(wx.ID_ANY, _("Copy address bar"))                # Bind events for Robocopy submenu        robocopy_menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.robocopy.copy), copy_item)        robocopy_menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.robocopy.move), move_item)        robocopy_menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.robocopy.paste), paste_item)        robocopy_menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self.robocopy.showMirrorBackupDialog), mirror_item)                # Bind events for other menu items        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.compression.compressZip), compress_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.clipboard.copyFileContent), copy_content_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.clipboard.copySelectedNames), copy_names_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.selection.invertSelection), invert_selection_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.fileOps.renameFile), rename_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.txt2folder.convert_txt_to_folder), txt_to_folder_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self.fileOps.saySize), say_size_item)        menu.Bind(wx.EVT_MENU, lambda evt: core.callLater(0, self._executeWithSilence, self._copyAddressBar), copy_address_item)                return menu    def _showContextMenu(self):        """Show the context menu asynchronously to avoid blocking"""        def show_menu():            try:                focus = api.getFocusObject()                if not focus or focus.appModule.appName != "explorer":                    ui.message(_("Not in File Explorer"))                    return                                import speech                speech.cancelSpeech()                                self.manager.contextMenuActive = True                self.manager.suppressAllAnnouncements = True                                last_focus = api.getFocusObject()                                menu = self._createContextMenu()                                frame = wx.Frame(gui.mainFrame, -1, "", pos=(0, 0), size=(0, 0))                try:                    frame.Show()                    frame.Raise()                                        frame.PopupMenu(menu)                                        if last_focus:                        last_focus.setFocus()                except Exception as e:                    log.error(f"Error displaying popup menu: {e}")                    ui.message(_("Error displaying context menu"))                finally:                    try:                        menu.Destroy()                    except:                        pass                    try:                        frame.Destroy()                    except:                        pass                    core.callLater(1000, lambda: setattr(self.manager, 'suppressAllAnnouncements', False))                    core.callLater(100, lambda: setattr(self.manager, 'contextMenuActive', False))                            except Exception as e:                log.error(f"Error in showContextMenu: {e}")                ui.message(_("Error opening context menu"))                self.manager.contextMenuActive = False                self.manager.suppressAllAnnouncements = False                wx.CallAfter(show_menu)    def script_openXPlorerContextMenu(self, gesture):        """Open xPlorer context menu"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("This command is only available in File Explorer."))            return                    self._showContextMenu()    script_openXPlorerContextMenu.__doc__ = _("Open xPlorer context menu")    script_openXPlorerContextMenu.category = _("xPlorer")    script_openXPlorerContextMenu.gestures = ["kb(desktop):NVDA+alt+x"]    def chooseNVDAObjectOverlayClasses(self, obj, clsList):        self.manager.chooseNVDAObjectOverlayClasses(obj, clsList)    def event_gainFocus(self, obj, nextHandler):        self.manager.event_gainFocus(obj, nextHandler)    def event_focusEntered(self, obj, nextHandler):        self.manager.event_focusEntered(obj, nextHandler)    def event_foreground(self, obj, nextHandler):        self.manager.event_foreground(obj, nextHandler)    def event_UIA_elementSelected(self, obj, nextHandler):        self.manager.event_UIA_elementSelected(obj, nextHandler)