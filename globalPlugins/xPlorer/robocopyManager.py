# robocopyManager.pyimport uiimport apiimport osimport wximport guiimport gui.guiHelperimport subprocessimport jsonimport threadingimport timefrom datetime import datetime, timedeltafrom logHandler import logimport addonHandlerimport tempfileimport urllib.parseimport tonesimport globalVarsaddonHandler.initTranslation()class MirrorBackupDialog(wx.Dialog):    def __init__(self, parent, source_path, existing_config=None, all_configs=None):        super().__init__(parent, title=_("Mirror Backup Settings"))        self.source_path = source_path        self.destinations = []        self.sync_enabled = False        self.sync_interval = 900  # 15 minutes default        # Set default time to current time        current_time = datetime.now().strftime("%H:%M")        self.scheduled_time = current_time        self.existing_config = existing_config        self.all_configs = all_configs or []        self.current_config = None        self.InitUI()            def InitUI(self):        mainSizer = wx.BoxSizer(wx.VERTICAL)        sHelper = gui.guiHelper.BoxSizerHelper(self, orientation=wx.VERTICAL)                # Source folder section - Display all saved sources in a ListBox        source_section_title = wx.StaticText(self, label=_("Source Folder Information"))        source_section_title.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))        sHelper.addItem(source_section_title)                sHelper.addItem(wx.StaticText(self, label=_("Source folders (select to edit):")))        self.source_list = wx.ListBox(self, style=wx.LB_SINGLE, size=(-1, 80))        self.source_list.SetName(_("Source folders list"))                # Add all saved sources to the list        all_sources = []        if self.all_configs:            for config in self.all_configs:                if 'source' in config:                    all_sources.append(config['source'])                # Add current source if not already in list        if self.source_path and self.source_path not in all_sources:            all_sources.insert(0, self.source_path)        elif self.source_path:            # Move current source to top            all_sources.remove(self.source_path)            all_sources.insert(0, self.source_path)                for source in all_sources:            self.source_list.Append(source)                # Select current source        if self.source_path:            for i in range(self.source_list.GetCount()):                if self.source_list.GetString(i) == self.source_path:                    self.source_list.SetSelection(i)                    break                sHelper.addItem(self.source_list, proportion=1, flag=wx.EXPAND)                # Remove source button        self.remove_source_btn = wx.Button(self, label=_("Remove selected source"))        sHelper.addItem(self.remove_source_btn)                sHelper.addItem(wx.StaticText(self, label=""))  # Empty space                # Destinations section        destinations_title = wx.StaticText(self, label=_("Current Destination Folders"))        destinations_title.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))        sHelper.addItem(destinations_title)                sHelper.addItem(wx.StaticText(self, label=_("Destination folders:")))        self.dest_list = wx.ListBox(self, style=wx.LB_SINGLE, size=(-1, 120))        self.dest_list.SetName(_("Destination folders list"))        sHelper.addItem(self.dest_list, proportion=1, flag=wx.EXPAND)                # Add/Remove destination buttons        btn_sizer = wx.BoxSizer(wx.HORIZONTAL)        add_btn = wx.Button(self, label=_("Add destination folder"))        remove_btn = wx.Button(self, label=_("Remove selected destination"))        btn_sizer.Add(add_btn, proportion=1, flag=wx.RIGHT, border=5)        btn_sizer.Add(remove_btn, proportion=1)        sHelper.addItem(btn_sizer)                sHelper.addItem(wx.StaticText(self, label=""))  # Empty space                # Sync options section        sync_title = wx.StaticText(self, label=_("Synchronization Settings"))        sync_title.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD))        sHelper.addItem(sync_title)                self.sync_checkbox = sHelper.addItem(wx.CheckBox(self, label=_("Enable automatic synchronization")))        self.sync_checkbox.SetValue(False)                # Sync interval (only enabled when sync is checked)        interval_label = wx.StaticText(self, label=_("Synchronization interval:"))        sHelper.addItem(interval_label)        self.interval_combo = wx.ComboBox(self, choices=[            _("15 minutes"),            _("30 minutes"),             _("1 hour"),            _("1 day"),             _("7 days"),            _("15 days"),            _("1 month")        ], style=wx.CB_READONLY)        self.interval_combo.SetSelection(0)        self.interval_combo.Enable(False)        self.interval_combo.SetName(_("Synchronization interval selection"))        sHelper.addItem(self.interval_combo)                # Scheduled time control (only shown for intervals >= 1 day)        self.time_panel = wx.Panel(self)        time_sizer = wx.BoxSizer(wx.HORIZONTAL)        time_label = wx.StaticText(self.time_panel, label=_("Scheduled time:"))        time_sizer.Add(time_label, flag=wx.RIGHT | wx.ALIGN_CENTER_VERTICAL, border=5)        self.time_ctrl = wx.TextCtrl(self.time_panel, value=self.scheduled_time, size=(60, -1))        self.time_ctrl.SetName(_("Scheduled time input"))        time_sizer.Add(self.time_ctrl)        self.time_panel.SetSizer(time_sizer)        self.time_panel.Hide()  # Hidden by default        sHelper.addItem(self.time_panel)                # Buttons - Fixed order: Start synchronization before OK        btn_sizer2 = wx.BoxSizer(wx.HORIZONTAL)        clear_btn = wx.Button(self, label=_("Clear all settings"))        sync_btn = wx.Button(self, label=_("Start synchronization"))        ok_btn = wx.Button(self, label=_("OK"))        cancel_btn = wx.Button(self, label=_("Cancel"))                btn_sizer2.Add(clear_btn, proportion=1, flag=wx.RIGHT, border=5)        btn_sizer2.Add(sync_btn, proportion=1, flag=wx.RIGHT, border=5)        btn_sizer2.Add(ok_btn, proportion=1, flag=wx.RIGHT, border=5)        btn_sizer2.Add(cancel_btn, proportion=1)                sHelper.addItem(btn_sizer2, flag=wx.ALIGN_CENTER)                self.SetSizer(mainSizer)        mainSizer.Fit(self)        self.SetSize((600, 650))                self.CentreOnScreen()                # Load existing configuration if available        if self.existing_config:            self.loadExistingConfig()        elif self.source_path:            self.loadConfigForSource(self.source_path)                # Bind events        self.source_list.Bind(wx.EVT_LISTBOX, self.onSourceSelected)        add_btn.Bind(wx.EVT_BUTTON, self.onAddDestination)        remove_btn.Bind(wx.EVT_BUTTON, self.onRemoveDestination)        self.remove_source_btn.Bind(wx.EVT_BUTTON, self.onRemoveSource)        self.sync_checkbox.Bind(wx.EVT_CHECKBOX, self.onSyncCheck)        self.interval_combo.Bind(wx.EVT_COMBOBOX, self.onIntervalChange)        clear_btn.Bind(wx.EVT_BUTTON, self.onClear)        sync_btn.Bind(wx.EVT_BUTTON, self.onSync)        ok_btn.Bind(wx.EVT_BUTTON, self.onOk)        cancel_btn.Bind(wx.EVT_BUTTON, self.onCancel)        self.Bind(wx.EVT_CLOSE, self.onClose)        self.Bind(wx.EVT_CHAR_HOOK, self.onCharHook)                # Set focus to source list for accessibility        self.source_list.SetFocus()            def onCharHook(self, event):        """Handle ESC key to close dialog"""        if event.GetKeyCode() == wx.WXK_ESCAPE:            self.onCancel(None)        else:            event.Skip()            def loadConfigForSource(self, source_path):        """Load configuration for selected source"""        self.current_config = None        for config in self.all_configs:            if config.get('source') == source_path:                self.current_config = config                break                if self.current_config:            self.loadExistingConfig()        else:            # New configuration for this source            self.destinations = []            self.dest_list.Clear()            self.sync_checkbox.SetValue(False)            self.interval_combo.SetSelection(0)            self.interval_combo.Enable(False)            self.time_panel.Hide()            # Set current time as default for new configuration            current_time = datetime.now().strftime("%H:%M")            self.time_ctrl.SetValue(current_time)            self.Layout()            def loadExistingConfig(self):        """Load existing configuration into the dialog"""        config = self.current_config or self.existing_config        if not config:            return                    self.destinations = config.get('destinations', [])        self.dest_list.Clear()        for dest in self.destinations:            self.dest_list.Append(dest)                self.sync_checkbox.SetValue(config.get('enabled', False))                # Set interval        interval = config.get('interval', 900)        intervals = [900, 1800, 3600, 86400, 604800, 1296000, 2592000]  # 15m, 30m, 1h, 1d, 7d, 15d, 30d        if interval in intervals:            index = intervals.index(interval)            self.interval_combo.SetSelection(index)                # Set scheduled time if available        self.scheduled_time = config.get('scheduled_time', datetime.now().strftime("%H:%M"))        self.time_ctrl.SetValue(self.scheduled_time)                # Show/hide time panel based on interval        self.updateTimePanelVisibility()                # Enable interval combo if sync is enabled        self.interval_combo.Enable(self.sync_checkbox.GetValue())            def updateTimePanelVisibility(self):        """Show time panel only for intervals >= 1 day"""        interval_index = self.interval_combo.GetSelection()        intervals = [900, 1800, 3600, 86400, 604800, 1296000, 2592000]                if 0 <= interval_index < len(intervals):            current_interval = intervals[interval_index]            # Show time panel only for intervals of 1 day or more            if current_interval >= 86400:  # 1 day or more                self.time_panel.Show()            else:                self.time_panel.Hide()            self.Layout()            def onSourceSelected(self, event):        """Handle source selection change"""        selection = self.source_list.GetSelection()        if selection != wx.NOT_FOUND:            selected_source = self.source_list.GetString(selection)            self.source_path = selected_source            self.loadConfigForSource(selected_source)            ui.message(_("Selected source: {path}").format(path=selected_source))            def onAddDestination(self, event):        with wx.DirDialog(self, _("Choose destination folder")) as dialog:            if dialog.ShowModal() == wx.ID_OK:                dest_path = dialog.GetPath()                if dest_path not in self.destinations:                    self.destinations.append(dest_path)                    self.dest_list.Append(dest_path)                    # Announce the addition for screen reader users                    self.dest_list.SetSelection(self.dest_list.GetCount() - 1)                    ui.message(_("Added destination folder: {path}").format(path=dest_path))                    def onRemoveDestination(self, event):        selection = self.dest_list.GetSelection()        if selection != wx.NOT_FOUND:            removed_path = self.destinations[selection]            self.destinations.pop(selection)            self.dest_list.Delete(selection)            ui.message(_("Removed destination folder: {path}").format(path=removed_path))            # Set selection to next item or clear if empty            if self.dest_list.GetCount() > 0:                new_selection = min(selection, self.dest_list.GetCount() - 1)                self.dest_list.SetSelection(new_selection)                    def onRemoveSource(self, event):        """Remove selected source from list and configuration"""        selection = self.source_list.GetSelection()        if selection != wx.NOT_FOUND:            removed_source = self.source_list.GetString(selection)                        # Remove from list            self.source_list.Delete(selection)                        # Clear current configuration if this was the selected source            if removed_source == self.source_path:                self.source_path = None                self.destinations = []                self.dest_list.Clear()                self.sync_checkbox.SetValue(False)                self.interval_combo.SetSelection(0)                self.interval_combo.Enable(False)                self.time_panel.Hide()                # Reset to current time                current_time = datetime.now().strftime("%H:%M")                self.time_ctrl.SetValue(current_time)                self.current_config = None                        # Set selection to next item or clear if empty            if self.source_list.GetCount() > 0:                new_selection = min(selection, self.source_list.GetCount() - 1)                self.source_list.SetSelection(new_selection)                if new_selection != wx.NOT_FOUND:                    new_source = self.source_list.GetString(new_selection)                    self.source_path = new_source                    self.loadConfigForSource(new_source)                        ui.message(_("Remove Succeeded"))            # Return the removed source path so it can be removed from main configuration            self.removed_source = removed_source        else:            ui.message(_("No source selected"))                    def onSyncCheck(self, event):        enabled = self.sync_checkbox.GetValue()        self.interval_combo.Enable(enabled)        self.updateTimePanelVisibility()        if enabled:            ui.message(_("Automatic synchronization enabled"))        else:            ui.message(_("Automatic synchronization disabled"))        def onIntervalChange(self, event):        """Handle interval selection change"""        self.updateTimePanelVisibility()        interval_index = self.interval_combo.GetSelection()        intervals = [900, 1800, 3600, 86400, 604800, 1296000, 2592000]                if 0 <= interval_index < len(intervals):            current_interval = intervals[interval_index]            if current_interval >= 86400:  # 1 day or more                ui.message(_("Can change backup time"))                def onClear(self, event):        self.destinations = []        self.dest_list.Clear()        self.sync_checkbox.SetValue(False)        self.interval_combo.SetSelection(0)        self.interval_combo.Enable(False)        self.time_panel.Hide()        # Reset to current time        current_time = datetime.now().strftime("%H:%M")        self.time_ctrl.SetValue(current_time)        self.Layout()        ui.message(_("Clear All Succeeded"))            def onSync(self, event):        """Start synchronization with progress tracking"""        if not self.source_path:            ui.message(_("Please select a source folder"))            return                    if not self.destinations:            ui.message(_("Please add at least one destination folder"))            return                    # Validate scheduled time if shown        if self.time_panel.IsShown():            time_str = self.time_ctrl.GetValue().strip()            if not self.validateTimeFormat(time_str):                ui.message(_("Invalid time format. Please use HH:MM format (00:00 to 23:59)."))                self.time_ctrl.SetFocus()                return            self.scheduled_time = time_str                self.sync_enabled = self.sync_checkbox.GetValue()                # Convert interval to seconds        interval_index = self.interval_combo.GetSelection()        intervals = [900, 1800, 3600, 86400, 604800, 1296000, 2592000]  # 15m, 30m, 1h, 1d, 7d, 15d, 30d        if 0 <= interval_index < len(intervals):            self.sync_interval = intervals[interval_index]        else:            self.sync_interval = 900                    # Execute immediate synchronization with progress        self.executeImmediateSync()            def validateTimeFormat(self, time_str):        """Validate time format HH:MM"""        try:            if len(time_str) != 5 or time_str[2] != ':':                return False            hours = int(time_str[0:2])            minutes = int(time_str[3:5])            return 0 <= hours <= 23 and 0 <= minutes <= 59        except ValueError:            return False            def onOk(self, event):        """Save settings without starting synchronization"""        if not self.source_path:            ui.message(_("Please select a source folder"))            return                    if not self.destinations:            ui.message(_("Please add at least one destination folder"))            return                    # Validate scheduled time if shown        if self.time_panel.IsShown():            time_str = self.time_ctrl.GetValue().strip()            if not self.validateTimeFormat(time_str):                ui.message(_("Invalid time format. Please use HH:MM format (00:00 to 23:59)."))                self.time_ctrl.SetFocus()                return            self.scheduled_time = time_str                    self.sync_enabled = self.sync_checkbox.GetValue()                # Convert interval to seconds        interval_index = self.interval_combo.GetSelection()        intervals = [900, 1800, 3600, 86400, 604800, 1296000, 2592000]  # 15m, 30m, 1h, 1d, 7d, 15d, 30d        if 0 <= interval_index < len(intervals):            self.sync_interval = intervals[interval_index]        else:            self.sync_interval = 900                    self.EndModal(wx.ID_OK)            def onCancel(self, event):        self.EndModal(wx.ID_CANCEL)            def onClose(self, event):        self.EndModal(wx.ID_CANCEL)            def executeImmediateSync(self):        """Execute immediate synchronization with progress tracking and detailed reporting"""        try:            # Show progress dialog            style = wx.PD_APP_MODAL | wx.PD_CAN_ABORT | wx.PD_ELAPSED_TIME | wx.PD_REMAINING_TIME            progress_dialog = wx.ProgressDialog(_("Mirror Backup"), _("Starting synchronization..."),                                               maximum=100, parent=self, style=style)                        def update_progress(percent, message):                if progress_dialog and progress_dialog.IsShown():                    try:                        cont, skip = progress_dialog.Update(percent, message)                        # Play progress tone every 10%                        if percent % 10 == 0 and percent > 0 and percent < 100:                            wx.CallAfter(tones.beep, 800 + percent * 2, 50)                        return cont                    except Exception as e:                        log.error(f"Error updating progress: {e}")                        return True                return True                        def sync_thread():                try:                    start_time = time.time()                    successful_destinations = []                    failed_destinations = []                                        total_destinations = len(self.destinations)                                        # Initial announcement                    wx.CallAfter(ui.message, _("Starting synchronization for {source} to {count} destinations").format(                        source=os.path.basename(self.source_path), count=total_destinations))                                        for index, destination in enumerate(self.destinations):                        if not progress_dialog.IsShown():                            break                                                    # Calculate progress percentage                        base_progress = (index * 100) // total_destinations                        wx.CallAfter(update_progress, base_progress,                                    _("Analyzing changes for {destination}...").format(destination=os.path.basename(destination)))                                                # First, analyze changes using robocopy with /L (list only) option                        analyze_cmd = ['robocopy', self.source_path, destination, '/MIR', '/E', '/L', '/NJH', '/NJS', '/NS', '/NC']                        analyze_process = subprocess.Popen(analyze_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,                                                          universal_newlines=True, creationflags=subprocess.CREATE_NO_WINDOW)                                                # Parse analysis results                        new_files = 0                        updated_files = 0                        deleted_files = 0                        total_changes = 0                                                for line in analyze_process.stdout:                            line = line.strip()                            if 'New File' in line:                                new_files += 1                                total_changes += 1                            elif 'Newer' in line:                                updated_files += 1                                total_changes += 1                            elif 'Extra File' in line:                                deleted_files += 1                                total_changes += 1                                                analyze_process.wait()                                                # Report file changes with detailed information                        if total_changes > 0:                            change_message = _("Changes detected: {new} new files, {updated} updated files, {deleted} files to delete").format(                                new=new_files, updated=updated_files, deleted=deleted_files)                            wx.CallAfter(ui.message, _("{destination}: {changes}").format(                                destination=os.path.basename(destination), changes=change_message))                        else:                            wx.CallAfter(ui.message, _("{destination}: No changes detected").format(                                destination=os.path.basename(destination)))                                                # If no changes, skip to next destination                        if total_changes == 0:                            successful_destinations.append((destination, 0, 0, 0))                            continue                                                # Execute robocopy with mirror option and enhanced performance                        cmd = ['robocopy', self.source_path, destination, '/MIR', '/E', '/COPYALL', '/DCOPY:DAT',                               '/R:1', '/W:1', '/MT:16', '/NP', '/NDL', '/NFL']                        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,                                                  universal_newlines=True, creationflags=subprocess.CREATE_NO_WINDOW)                                                # Monitor progress with enhanced parsing                        last_percent = 0                        file_count = 0                        copied_files = 0                        actual_new = 0                        actual_updated = 0                        actual_deleted = 0                                                for line in process.stdout:                            if not progress_dialog.IsShown():                                process.terminate()                                break                                                            line = line.strip()                                                        # Parse file progress                            if '%' in line:                                try:                                    percent_str = line.split('%')[0].strip()                                    percent = int(percent_str)                                    if percent > last_percent:                                        last_percent = percent                                        # Calculate overall progress                                        overall_progress = base_progress + (percent * 100) // (total_destinations * 100)                                        wx.CallAfter(update_progress, overall_progress,                                                    _("Synchronizing to {destination}: {percent}%").format(                                                       destination=os.path.basename(destination), percent=percent))                                except ValueError:                                    pass                            # Parse file operations for detailed reporting                            elif 'New File' in line:                                actual_new += 1                                file_count += 1                            elif 'Newer' in line:                                actual_updated += 1                                file_count += 1                            elif 'Extra File' in line:                                actual_deleted += 1                                file_count += 1                                                        if file_count % 50 == 0:  # Update progress every 50 files                                progress_estimate = min(90, (file_count * 90) // max(1, total_changes))                                overall_progress = base_progress + (progress_estimate * 100) // (total_destinations * 100)                                wx.CallAfter(update_progress, overall_progress,                                           _("Processing files: {count}...").format(count=file_count))                                                return_code = process.wait()                                                # Verify after sync and get final statistics                        verify_cmd = ['robocopy', self.source_path, destination, '/MIR', '/E', '/L', '/NJH', '/NJS', '/NS', '/NC']                        verify_process = subprocess.Popen(verify_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,                                                         universal_newlines=True, creationflags=subprocess.CREATE_NO_WINDOW)                                                final_new = 0                        final_updated = 0                        final_deleted = 0                        final_total = 0                                                for line in verify_process.stdout:                            line = line.strip()                            if 'New File' in line:                                final_new += 1                                final_total += 1                            elif 'Newer' in line:                                final_updated += 1                                final_total += 1                            elif 'Extra File' in line:                                final_deleted += 1                                final_total += 1                                                verify_return_code = verify_process.wait()                                                # Report final statistics with detailed information                        if final_total > 0:                            final_message = _("Synchronization completed: {new} new files, {updated} updated files, {deleted} files deleted").format(                                new=final_new, updated=final_updated, deleted=final_deleted)                        else:                            final_message = _("Synchronization completed: No changes needed")                                                wx.CallAfter(ui.message, _("{destination}: {message}").format(                            destination=os.path.basename(destination), message=final_message))                                                if return_code <= 7 and verify_return_code == 0:                            successful_destinations.append((destination, final_new, final_updated, final_deleted))                        else:                            failed_destinations.append(destination)                                        # Calculate elapsed time                    elapsed_time = time.time() - start_time                    minutes, seconds = divmod(int(elapsed_time), 60)                    hours, minutes = divmod(minutes, 60)                                        time_message = ""                    if hours > 0:                        time_message = _("{hours} hours {minutes} minutes {seconds} seconds").format(hours=hours, minutes=minutes, seconds=seconds)                    elif minutes > 0:                        time_message = _("{minutes} minutes {seconds} seconds").format(minutes=minutes, seconds=seconds)                    else:                        time_message = _("{seconds} seconds").format(seconds=seconds)                                        # Report final summary with detailed information                    total_new = sum(stats[1] for stats in successful_destinations)                    total_updated = sum(stats[2] for stats in successful_destinations)                    total_deleted = sum(stats[3] for stats in successful_destinations)                    total_files = total_new + total_updated + total_deleted                                        if total_files > 0:                        summary_message = _("Total synchronization results: {new} new files, {updated} updated files, {deleted} files deleted").format(                            new=total_new, updated=total_updated, deleted=total_deleted)                    else:                        summary_message = _("Total synchronization results: No changes in any destination")                                        if successful_destinations and not failed_destinations:                        wx.CallAfter(update_progress, 100, _("Completed successfully"))                        final_announcement = _("Synchronization completed successfully to all {count} destinations in {time}. {summary}").format(                            count=len(successful_destinations), time=time_message, summary=summary_message)                        wx.CallAfter(ui.message, final_announcement)                        wx.CallAfter(tones.beep, 1500, 500)                    elif successful_destinations and failed_destinations:                        wx.CallAfter(update_progress, 100, _("Completed with warnings"))                        final_announcement = _("Synchronization partially completed: {success} successful, {failed} failed in {time}. {summary}").format(                            success=len(successful_destinations), failed=len(failed_destinations), time=time_message, summary=summary_message)                        wx.CallAfter(ui.message, final_announcement)                        wx.CallAfter(tones.beep, 1000, 300)                    else:                        wx.CallAfter(update_progress, 100, _("Failed"))                        final_announcement = _("Synchronization failed to all destinations in {time}").format(time=time_message)                        wx.CallAfter(ui.message, final_announcement)                        wx.CallAfter(tones.beep, 500, 500)                                        except Exception as e:                    log.error(f"Error in sync thread: {e}")                    wx.CallAfter(update_progress, 100, _("Error occurred"))                    error_message = _("Error during synchronization: {error}").format(error=str(e))                    wx.CallAfter(ui.message, error_message)                    wx.CallAfter(tones.beep, 500, 500)                finally:                    if progress_dialog:                        wx.CallAfter(progress_dialog.Destroy)                        # Start synchronization in separate thread            thread = threading.Thread(target=sync_thread)            thread.daemon = True            thread.start()                    except Exception as e:            log.error(f"Error starting synchronization: {e}")            ui.message(_("Error starting synchronization"))class RobocopyManager:    def __init__(self, plugin):        self.plugin = plugin        self.pending_source = None        self.pending_operation = None  # 'copy' or 'move'        self.mirror_timers = {}        self.mirror_configs = []        self.loadMirrorConfig()            def cleanup(self):        # Stop all timers        for source, timer_data in self.mirror_timers.items():            timer = timer_data.get('timer')            if timer and hasattr(timer, 'cancel'):                timer.cancel()                    def loadMirrorConfig(self):        """Load mirror backup configuration from file"""        try:            # Use NVDA user config directory for mirror.json            config_file = os.path.abspath(os.path.join(globalVars.appArgs.configPath, "mirror.json"))                        if not os.path.exists(config_file):                log.info("No mirror backup configuration file found, starting with empty configuration")                self.mirror_configs = []                return                            with open(config_file, 'r', encoding='utf-8') as f:                loaded_configs = json.load(f)                # Ensure we have a list                if isinstance(loaded_configs, list):                    self.mirror_configs = loaded_configs                else:                    log.error("Invalid mirror configuration format, expected list")                    self.mirror_configs = []                            log.info(f"Loaded {len(self.mirror_configs)} mirror backup configurations")                        # Start timers for enabled configurations            for config in self.mirror_configs:                if config.get('enabled', False):                    self.startMirrorTimer(config)                            except Exception as e:            log.error(f"Error loading mirror config: {e}")            self.mirror_configs = []                def getMirrorConfig(self, source_path):        """Get existing mirror configuration for source path"""        for config in self.mirror_configs:            if config.get('source') == source_path:                return config        return None                def saveMirrorConfig(self):        """Save mirror backup configuration to file"""        try:            # Use NVDA user config directory for mirror.json            config_file = os.path.abspath(os.path.join(globalVars.appArgs.configPath, "mirror.json"))                        with open(config_file, 'w', encoding='utf-8') as f:                json.dump(self.mirror_configs, f, indent=2, ensure_ascii=False)                            log.info(f"Saved {len(self.mirror_configs)} mirror backup configurations")                    except Exception as e:            log.error(f"Error saving mirror config: {e}")            ui.message(_("Error saving mirror backup configuration"))                def calculateNextRunTime(self, config):        """Calculate next run time based on interval and scheduled time"""        interval = config.get('interval', 900)        scheduled_time = config.get('scheduled_time', '00:00')                now = datetime.now()                # For intervals less than 1 day, just add the interval        if interval < 86400:            return now + timedelta(seconds=interval)                # For intervals of 1 day or more, calculate based on scheduled time        try:            # Parse scheduled time            hours, minutes = map(int, scheduled_time.split(':'))            target_time = now.replace(hour=hours, minute=minutes, second=0, microsecond=0)                        # If target time is in the past today, move to next interval            if target_time <= now:                if interval == 86400:  # 1 day                    target_time += timedelta(days=1)                elif interval == 604800:  # 7 days                    target_time += timedelta(days=7)                elif interval == 1296000:  # 15 days                    target_time += timedelta(days=15)                elif interval == 2592000:  # 30 days (approx 1 month)                    target_time += timedelta(days=30)                        return target_time        except Exception as e:            log.error(f"Error calculating next run time: {e}")            # Fallback: add interval seconds            return now + timedelta(seconds=interval)                def startMirrorTimer(self, config):        """Start timer for mirror backup with proper scheduling"""        source = config.get('source')        interval = config.get('interval', 900)                if not source or not os.path.exists(source):            log.warning(f"Cannot start timer for non-existent source: {source}")            return                    # Stop existing timer if any        if source in self.mirror_timers:            timer_data = self.mirror_timers[source]            timer = timer_data.get('timer')            if timer and hasattr(timer, 'cancel'):                timer.cancel()                        # Calculate delay until next run        next_run = self.calculateNextRunTime(config)        delay = (next_run - datetime.now()).total_seconds()                # Ensure delay is positive        if delay < 0:            delay = interval                    log.info(f"Starting mirror backup timer for {source}, delay: {delay} seconds")                    # Create new timer with improved error handling        def timer_function():            try:                time.sleep(delay)                # Execute backup in main thread to avoid threading issues                wx.CallAfter(self.executeMirrorBackup, config)            except Exception as e:                log.error(f"Error in mirror timer thread: {e}")                # Restart timer on error                wx.CallAfter(self.startMirrorTimer, config)                    timer = threading.Timer(delay, timer_function)        timer.daemon = True        timer.start()                self.mirror_timers[source] = {            'timer': timer,            'config': config,            'next_run': next_run        }                # Announce next scheduled time for intervals >= 1 day        if interval >= 86400:            scheduled_time = config.get('scheduled_time', '00:00')            interval_name = self.getIntervalName(interval)            next_run_str = next_run.strftime("%Y-%m-%d %H:%M")            announcement = _("Next {interval} backup scheduled for {time}").format(                interval=interval_name, time=next_run_str)            wx.CallAfter(ui.message, announcement)            log.info(f"Scheduled {interval_name} backup for {source} at {next_run_str}")        else:            log.info(f"Started mirror backup timer for {source}, interval: {interval} seconds")            def getIntervalName(self, interval):        """Get human-readable interval name"""        intervals = {            900: _("15 minutes"),            1800: _("30 minutes"),            3600: _("1 hour"),            86400: _("1 day"),            604800: _("7 days"),            1296000: _("15 days"),            2592000: _("1 month")        }        return intervals.get(interval, _("unknown interval"))            def executeMirrorBackup(self, config):        """Execute mirror backup operation with progress tracking and file change reporting"""        source = config.get('source')        destinations = config.get('destinations', [])                if not source or not destinations:            log.warning("Invalid mirror backup configuration: missing source or destinations")            return                    try:            # Announce start of scheduled backup            interval = config.get('interval', 900)            interval_name = self.getIntervalName(interval)            announcement = _("Starting scheduled {interval} backup for {source}").format(                interval=interval_name, source=os.path.basename(source))            wx.CallAfter(ui.message, announcement)            log.info(f"Executing scheduled backup for {source}")                        # Execute backup in background without blocking UI            def backup_thread():                try:                    start_time = time.time()                    successful_destinations = []                    failed_destinations = []                    total_destinations = len(destinations)                                        # Initial announcement                    wx.CallAfter(ui.message, _("Starting background synchronization for {source} to {count} destinations").format(                        source=os.path.basename(source), count=total_destinations))                                        for index, destination in enumerate(destinations):                        # First, analyze changes using robocopy with /L (list only) option                        analyze_cmd = ['robocopy', source, destination, '/MIR', '/E', '/L', '/NJH', '/NJS', '/NS', '/NC']                        analyze_process = subprocess.Popen(analyze_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,                                                          universal_newlines=True, creationflags=subprocess.CREATE_NO_WINDOW)                                                # Parse analysis results                        new_files = 0                        updated_files = 0                        deleted_files = 0                        total_changes = 0                                                for line in analyze_process.stdout:                            line = line.strip()                            if 'New File' in line:                                new_files += 1                                total_changes += 1                            elif 'Newer' in line:                                updated_files += 1                                total_changes += 1                            elif 'Extra File' in line:                                deleted_files += 1                                total_changes += 1                                                analyze_process.wait()                                                # Report file changes for scheduled backup                        if total_changes > 0:                            change_message = _("Background sync changes: {new} new files, {updated} updated files, {deleted} files to delete").format(                                new=new_files, updated=updated_files, deleted=deleted_files)                            wx.CallAfter(ui.message, _("{destination}: {changes}").format(                                destination=os.path.basename(destination), changes=change_message))                        else:                            wx.CallAfter(ui.message, _("{destination}: No changes detected for background sync").format(                                destination=os.path.basename(destination)))                                                # If no changes, skip to next destination but still count as successful                        if total_changes == 0:                            successful_destinations.append((destination, 0, 0, 0))                            continue                                                # Execute robocopy with mirror option and enhanced performance                        cmd = ['robocopy', source, destination, '/MIR', '/E', '/COPYALL', '/DCOPY:DAT',                               '/R:1', '/W:1', '/MT:16', '/NP', '/NDL', '/NFL']                        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,                                                  universal_newlines=True, creationflags=subprocess.CREATE_NO_WINDOW)                                                # Monitor progress                        file_count = 0                        actual_new = 0                        actual_updated = 0                        actual_deleted = 0                                                for line in process.stdout:                            line = line.strip()                                                        # Parse file operations for detailed reporting                            if 'New File' in line:                                actual_new += 1                                file_count += 1                            elif 'Newer' in line:                                actual_updated += 1                                file_count += 1                            elif 'Extra File' in line:                                actual_deleted += 1                                file_count += 1                                                return_code = process.wait()                                                # Verify after sync and get final statistics                        verify_cmd = ['robocopy', source, destination, '/MIR', '/E', '/L', '/NJH', '/NJS', '/NS', '/NC']                        verify_process = subprocess.Popen(verify_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,                                                         universal_newlines=True, creationflags=subprocess.CREATE_NO_WINDOW)                                                final_new = 0                        final_updated = 0                        final_deleted = 0                        final_total = 0                                                for line in verify_process.stdout:                            line = line.strip()                            if 'New File' in line:                                final_new += 1                                final_total += 1                            elif 'Newer' in line:                                final_updated += 1                                final_total += 1                            elif 'Extra File' in line:                                final_deleted += 1                                final_total += 1                                                verify_return_code = verify_process.wait()                                                # Report final statistics for scheduled backup                        if final_total > 0:                            final_message = _("Background sync completed: {new} new files, {updated} updated files, {deleted} files deleted").format(                                new=final_new, updated=final_updated, deleted=final_deleted)                        else:                            final_message = _("Background sync completed: No changes needed")                                                wx.CallAfter(ui.message, _("{destination}: {message}").format(                            destination=os.path.basename(destination), message=final_message))                                                if return_code <= 7 and verify_return_code == 0:                            successful_destinations.append((destination, final_new, final_updated, final_deleted))                        else:                            failed_destinations.append(destination)                                        # Calculate elapsed time                    elapsed_time = time.time() - start_time                    minutes, seconds = divmod(int(elapsed_time), 60)                    hours, minutes = divmod(minutes, 60)                                        time_message = ""                    if hours > 0:                        time_message = _("{hours} hours {minutes} minutes {seconds} seconds").format(hours=hours, minutes=minutes, seconds=seconds)                    elif minutes > 0:                        time_message = _("{minutes} minutes {seconds} seconds").format(minutes=minutes, seconds=seconds)                    else:                        time_message = _("{seconds} seconds").format(seconds=seconds)                                        # Report final summary for scheduled backup                    total_new = sum(stats[1] for stats in successful_destinations)                    total_updated = sum(stats[2] for stats in successful_destinations)                    total_deleted = sum(stats[3] for stats in successful_destinations)                    total_files = total_new + total_updated + total_deleted                                        if total_files > 0:                        summary_message = _("Background sync summary: {new} new files, {updated} updated files, {deleted} files deleted").format(                            new=total_new, updated=total_updated, deleted=total_deleted)                    else:                        summary_message = _("Background sync summary: No changes in any destination")                                        if successful_destinations and not failed_destinations:                        final_announcement = _("Background synchronization completed successfully to all {count} destinations in {time}. {summary}").format(                            count=len(successful_destinations), time=time_message, summary=summary_message)                        wx.CallAfter(ui.message, final_announcement)                        wx.CallAfter(tones.beep, 1500, 500)                    elif successful_destinations and failed_destinations:                        final_announcement = _("Background synchronization partially completed: {success} successful, {failed} failed in {time}. {summary}").format(                            success=len(successful_destinations), failed=len(failed_destinations), time=time_message, summary=summary_message)                        wx.CallAfter(ui.message, final_announcement)                        wx.CallAfter(tones.beep, 1000, 300)                    else:                        final_announcement = _("Background synchronization failed to all destinations in {time}").format(time=time_message)                        wx.CallAfter(ui.message, final_announcement)                        wx.CallAfter(tones.beep, 500, 500)                                        except Exception as e:                    log.error(f"Error in background backup thread: {e}")                    error_message = _("Error during background synchronization: {error}").format(error=str(e))                    wx.CallAfter(ui.message, error_message)                    wx.CallAfter(tones.beep, 500, 500)                finally:                    # Restart timer for next execution                    wx.CallAfter(self.startMirrorTimer, config)                        # Start backup in separate thread            thread = threading.Thread(target=backup_thread)            thread.daemon = True            thread.start()                    except Exception as e:            log.error(f"Error starting background backup: {e}")            # Restart timer even if there was an error            self.startMirrorTimer(config)            def copy(self):        """Copy operation"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("Not in File Explorer"))            return                    selectedItems, shellWindow = self.plugin._getSelectedItems()        if not selectedItems:            ui.message(_("No items selected"))            return                    if len(selectedItems) > 1:            ui.message(_("Please select only one file or folder for copy"))            return                    source_path = selectedItems[0][1]        self.pending_source = source_path        self.pending_operation = 'copy'                ui.message(_("Source selected for robocopy: {name}").format(name=os.path.basename(source_path)))            def move(self):        """Move operation"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("Not in File Explorer"))            return                    selectedItems, shellWindow = self.plugin._getSelectedItems()        if not selectedItems:            ui.message(_("No items selected"))            return                    if len(selectedItems) > 1:            ui.message(_("Please select only one file or folder for move"))            return                    source_path = selectedItems[0][1]        self.pending_source = source_path        self.pending_operation = 'move'                ui.message(_("Source selected for robomove: {name}").format(name=os.path.basename(source_path)))            def paste(self):        """Paste operation to destination with progress tracking"""        if not self.pending_source or not self.pending_operation:            ui.message(_("No pending copy or move operation. Please select source first."))            return                    focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("Not in File Explorer"))            return                    # Get destination path from current focused explorer window using LocationURL        try:            shellWindow = self.plugin._getActiveExplorerWindow()            if shellWindow:                destination_path = shellWindow.LocationURL                if destination_path.startswith('file:///'):                    destination_path = destination_path[8:]  # Remove 'file:///' prefix                # Decode URL encoding                destination_path = urllib.parse.unquote(destination_path)                                if not os.path.isdir(destination_path):                    ui.message(_("Please navigate to a valid destination folder"))                    return                                    self.executePendingOperation(destination_path)            else:                ui.message(_("Could not determine destination folder"))                        except Exception as e:            log.error(f"Error getting destination path: {e}")            ui.message(_("Error getting destination folder"))            def executePendingOperation(self, destination_path):        """Execute pending copy or move operation with enhanced progress tracking"""        if not self.pending_source or not self.pending_operation:            return False                    start_time = time.time()                    try:            # If source is a folder, we need to copy/move the entire folder structure            if os.path.isdir(self.pending_source):                # For folders, we copy the folder itself to the destination                # The destination should be the parent directory where we want the folder to be placed                folder_name = os.path.basename(self.pending_source)                final_destination = os.path.join(destination_path, folder_name)                                if not os.path.exists(destination_path):                    try:                        os.makedirs(destination_path)                    except Exception as e:                        ui.message(_("Error creating destination folder: {error}").format(error=str(e)))                        return False            else:                # For files, the destination is the folder where the file should be placed                final_destination = destination_path                if not os.path.exists(final_destination):                    try:                        os.makedirs(final_destination)                    except Exception as e:                        ui.message(_("Error creating destination folder: {error}").format(error=str(e)))                        return False                        if self.pending_operation == 'copy':                # Enhanced robocopy command for fast copying                cmd = ['robocopy', self.pending_source, final_destination, '/E', '/COPYALL', '/DCOPY:DAT',                       '/R:1', '/W:1', '/MT:16', '/NP', '/NDL', '/NFL']                operation_name = _("copy")            else:  # move                # Enhanced robocopy command for fast moving                cmd = ['robocopy', self.pending_source, final_destination, '/E', '/MOVE', '/COPYALL', '/DCOPY:DAT',                       '/R:1', '/W:1', '/MT:16', '/NP', '/NDL', '/NFL']                operation_name = _("move")                            # Show progress dialog            style = wx.PD_APP_MODAL | wx.PD_CAN_ABORT | wx.PD_ELAPSED_TIME | wx.PD_REMAINING_TIME            progress_dialog = wx.ProgressDialog(_(operation_name.capitalize()), _("Starting fast {operation}...").format(operation=operation_name),                                               maximum=100, parent=None, style=style)                        def update_progress(percent, message):                if progress_dialog and progress_dialog.IsShown():                    try:                        cont, skip = progress_dialog.Update(percent, message)                        # Play progress tone every 10%                        if percent % 10 == 0 and percent > 0 and percent < 100:                            wx.CallAfter(tones.beep, 800 + percent * 2, 50)                        return cont                    except Exception as e:                        log.error(f"Error updating progress: {e}")                        return True                return True                        def operation_thread():                try:                    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,                                              universal_newlines=True, shell=True)                                        last_percent = 0                    file_count = 0                    total_files = 0                                        for line in process.stdout:                        if not progress_dialog.IsShown():                            process.terminate()                            break                                                    line = line.strip()                                                # Parse file progress                        if '%' in line:                            try:                                percent_str = line.split('%')[0].strip()                                percent = int(percent_str)                                if percent > last_percent:                                    last_percent = percent                                    wx.CallAfter(update_progress, percent,                                                _("Fast {operation}: {percent}%").format(operation=operation_name, percent=percent))                            except ValueError:                                pass                        # Parse file count for better progress estimation                        elif 'New File' in line or 'New Dir' in line:                            file_count += 1                            if file_count % 100 == 0:  # Update progress every 100 files                                progress_estimate = min(90, (file_count * 90) // max(1, total_files))                                wx.CallAfter(update_progress, progress_estimate,                                           _("Fast {operation}: {count} files processed").format(operation=operation_name, count=file_count))                                        return_code = process.wait()                                        # Calculate elapsed time                    elapsed_time = time.time() - start_time                    minutes, seconds = divmod(int(elapsed_time), 60)                    hours, minutes = divmod(minutes, 60)                                        time_message = ""                    if hours > 0:                        time_message = _("{hours} hours {minutes} minutes {seconds} seconds").format(hours=hours, minutes=minutes, seconds=seconds)                    elif minutes > 0:                        time_message = _("{minutes} minutes {seconds} seconds").format(minutes=minutes, seconds=seconds)                    else:                        time_message = _("{seconds} seconds").format(seconds=seconds)                                        if return_code <= 7:                        wx.CallAfter(update_progress, 100, _("Fast {operation} completed").format(operation=operation_name))                        success_message = _("Fast {operation} completed successfully in {time}").format(operation=operation_name, time=time_message)                        wx.CallAfter(ui.message, success_message)                        wx.CallAfter(tones.beep, 1500, 500)  # Success beep                    else:                        wx.CallAfter(update_progress, 100, _("Fast {operation} completed with warnings").format(operation=operation_name))                        warning_message = _("Fast {operation} completed with warnings in {time}").format(operation=operation_name, time=time_message)                        wx.CallAfter(ui.message, warning_message)                        wx.CallAfter(tones.beep, 1000, 300)  # Warning beep                                        except Exception as e:                    log.error(f"Error in fast {operation_name} thread: {e}")                    elapsed_time = time.time() - start_time                    minutes, seconds = divmod(int(elapsed_time), 60)                    time_message = _("{minutes} minutes {seconds} seconds").format(minutes=minutes, seconds=seconds) if minutes > 0 else _("{seconds} seconds").format(seconds=seconds)                    wx.CallAfter(update_progress, 100, _("Fast {operation} failed").format(operation=operation_name))                    error_message = _("Error during fast {operation} after {time}: {error}").format(operation=operation_name, time=time_message, error=str(e))                    wx.CallAfter(ui.message, error_message)                    wx.CallAfter(tones.beep, 500, 500)  # Error beep                finally:                    # Safely destroy progress dialog                    if progress_dialog:                        wx.CallAfter(progress_dialog.Destroy)                    # Clear pending operation                    self.pending_source = None                    self.pending_operation = None                        # Start operation in separate thread            thread = threading.Thread(target=operation_thread)            thread.daemon = True            thread.start()                        # Announce fast operation start            ui.message(_("Starting fast {operation} with enhanced performance...").format(operation=operation_name))            return True                    except Exception as e:            log.error(f"Error executing fast {self.pending_operation}: {e}")            ui.message(_("Error executing fast {operation}: {error}").format(                operation=self.pending_operation, error=str(e)))            return False                def showMirrorBackupDialog(self):        """Show mirror backup configuration dialog"""        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("Not in File Explorer"))            return                    selectedItems, shellWindow = self.plugin._getSelectedItems()        if not selectedItems:            ui.message(_("No items selected"))            return                    if len(selectedItems) > 1:            ui.message(_("Please select only one folder for mirror backup"))            return                    source_path = selectedItems[0][1]        if not os.path.isdir(source_path):            ui.message(_("Please select a folder for mirror backup"))            return                    # Get existing configuration for this source        existing_config = self.getMirrorConfig(source_path)                if existing_config:            ui.message(_("Loading existing mirror backup configuration for {folder}").format(folder=os.path.basename(source_path)))        else:            ui.message(_("Creating new mirror backup configuration for {folder}").format(folder=os.path.basename(source_path)))                    def show_dialog():            try:                dialog = MirrorBackupDialog(gui.mainFrame, source_path, existing_config, self.mirror_configs)                # Pass robocopy manager reference to dialog                dialog._robocopy_manager = self                dialog.SetFocus()                dialog.Raise()                                result = dialog.ShowModal()                                removed_source = getattr(dialog, 'removed_source', None)                if removed_source:                    # Remove the source from configuration                    self.mirror_configs = [c for c in self.mirror_configs if c.get('source') != removed_source]                    # Stop timer if exists                    if removed_source in self.mirror_timers:                        timer_data = self.mirror_timers[removed_source]                        timer = timer_data.get('timer')                        if timer and hasattr(timer, 'cancel'):                            timer.cancel()                        del self.mirror_timers[removed_source]                    self.saveMirrorConfig()                    ui.message(_("Source {path} removed from mirror backup configuration").format(path=removed_source))                                if result == wx.ID_OK and dialog.source_path:                    # Setup scheduled backup if enabled                    self.setupMirrorBackup(                        dialog.source_path,                        dialog.destinations,                        dialog.sync_enabled,                        dialog.sync_interval,                        dialog.scheduled_time                    )                                    dialog.Destroy()            except Exception as e:                log.error(f"Error showing mirror backup dialog: {e}")                ui.message(_("Error opening mirror backup dialog"))                    wx.CallAfter(show_dialog)            def setupMirrorBackup(self, source, destinations, enabled, interval, scheduled_time="00:00"):        """Setup mirror backup configuration"""        config = {            'source': source,            'destinations': destinations,            'enabled': enabled,            'interval': interval,            'scheduled_time': scheduled_time,            'last_updated': datetime.now().isoformat()        }                    # Remove existing config for same source        self.mirror_configs = [c for c in self.mirror_configs if c.get('source') != source]                if enabled and destinations:            self.mirror_configs.append(config)            self.startMirrorTimer(config)                        # Announce configuration details            interval_name = self.getIntervalName(interval)            if interval >= 86400:  # 1 day or more                announcement = _("Scheduled mirror backup configured for {source} to {count} destinations, {interval} at {time}").format(                    source=os.path.basename(source), count=len(destinations),                     interval=interval_name, time=scheduled_time)            else:                announcement = _("Scheduled mirror backup configured for {source} to {count} destinations, interval: {interval}").format(                    source=os.path.basename(source), count=len(destinations),                     interval=interval_name)            ui.message(announcement)        else:            # Stop timer if exists            if source in self.mirror_timers:                timer_data = self.mirror_timers[source]                timer = timer_data.get('timer')                if timer and hasattr(timer, 'cancel'):                    timer.cancel()                del self.mirror_timers[source]            ui.message(_("Scheduled mirror backup disabled for {source}").format(source=os.path.basename(source)))                    self.saveMirrorConfig()