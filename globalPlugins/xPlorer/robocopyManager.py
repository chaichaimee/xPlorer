# robocopyManager.pyimport uiimport apiimport osimport wximport guiimport gui.guiHelperimport subprocessimport jsonimport threadingimport timefrom datetime import datetime, timedeltafrom logHandler import logimport addonHandlerimport urllib.parseimport tonesimport globalVarsimport tempfileimport shutiladdonHandler.initTranslation()class ProgressDialog(wx.Dialog):    """Dialog to show progress for robocopy operations"""    def __init__(self, parent, title, total_operations):        super().__init__(            parent,            title=title,            style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER        )        self.total_operations = total_operations        self.current_operation = 0        self.is_cancelled = False        self.last_progress_time = 0        self.progress_interval = 1  # Update progress every 1 second        self.start_time = time.time()        self.InitUI()        self.CentreOnScreen()            def InitUI(self):        mainSizer = wx.BoxSizer(wx.VERTICAL)        sHelper = gui.guiHelper.BoxSizerHelper(self, orientation=wx.VERTICAL)                self.progress_label = wx.StaticText(self, label=_("Preparing operation..."))        sHelper.addItem(self.progress_label)                self.gauge = wx.Gauge(self, range=100)        sHelper.addItem(self.gauge, proportion=0, flag=wx.EXPAND)                # Add time estimation label        self.time_label = wx.StaticText(self, label="")        sHelper.addItem(self.time_label)                # Add speed information        self.speed_label = wx.StaticText(self, label="")        sHelper.addItem(self.speed_label)                btn_sizer = wx.BoxSizer(wx.HORIZONTAL)        self.cancel_btn = wx.Button(self, label=_("Cancel"))        self.minimize_btn = wx.Button(self, label=_("Minimize"))        btn_sizer.Add(self.cancel_btn, 1, wx.RIGHT, 5)        btn_sizer.Add(self.minimize_btn, 1)        sHelper.addItem(btn_sizer, flag=wx.ALIGN_CENTER)                mainSizer.Add(sHelper.sizer, 1, wx.EXPAND|wx.ALL, 10)        self.SetSizer(mainSizer)        mainSizer.Fit(self)        self.SetSize((450, 200))                self.cancel_btn.Bind(wx.EVT_BUTTON, self.onCancel)        self.minimize_btn.Bind(wx.EVT_BUTTON, self.onMinimize)        self.Bind(wx.EVT_CLOSE, self.onCancel)            def onCancel(self, evt):        self.is_cancelled = True        self.EndModal(wx.ID_CANCEL)            def onMinimize(self, evt):        self.Iconize(True)            def UpdateProgress(self, current, total, operation_name="", estimated_time="", speed=""):        """Update progress bar and label with rate limiting"""        if self.is_cancelled:            return False                    current_time = time.time()        # Only update UI at specified interval to prevent freezing        if current_time - self.last_progress_time < self.progress_interval:            return True                    self.last_progress_time = current_time                percentage = int((current / total) * 100) if total > 0 else 0        self.gauge.SetValue(percentage)                if operation_name:            # Shorten long file names for display            display_name = os.path.basename(operation_name)            if len(display_name) > 30:                display_name = display_name[:15] + "..." + display_name[-15:]            label_text = _("Processing: {}").format(display_name)        else:            label_text = _("Progress: {}%").format(percentage)                    self.progress_label.SetLabel(label_text)                # Update time estimation if provided        if estimated_time:            self.time_label.SetLabel(_("Estimated time remaining: {}").format(estimated_time))        else:            elapsed = int(current_time - self.start_time)            if elapsed > 0:                self.time_label.SetLabel(_("Elapsed time: {} seconds").format(elapsed))            else:                self.time_label.SetLabel("")                        # Update speed information        if speed:            self.speed_label.SetLabel(_("Speed: {}").format(speed))        else:            self.speed_label.SetLabel("")                    self.progress_label.GetContainingSizer().Layout()                # Play progress tone every 25% for feedback        if percentage > 0 and percentage % 25 == 0:            if percentage == 25:                tones.beep(800, 100)            elif percentage == 50:                tones.beep(1000, 100)            elif percentage == 75:                tones.beep(1200, 100)                # Process pending events but don't yield too much        wx.GetApp().Yield(True)        return Trueclass MirrorBackupDialog(wx.Dialog):    def __init__(self, parent, source_path, existing_config=None, all_configs=None):        super().__init__(            parent,            title=_("Mirror Backup Settings"),            style=wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER        )        self.source_path = source_path        self.destinations = []        self.sync_enabled = False        self.sync_interval = 900        self.scheduled_time = datetime.now().strftime("%H:%M")        self.existing_config = existing_config        self.all_configs = all_configs or []        self.current_config = None        self.removed_source = None        self.InitUI()        self.CentreOnScreen()            def InitUI(self):        mainSizer = wx.BoxSizer(wx.VERTICAL)        sHelper = gui.guiHelper.BoxSizerHelper(self, orientation=wx.VERTICAL)        sHelper.addItem(wx.StaticText(self, label=_("Source folders (select to edit):")))        self.source_list = wx.ListBox(self, style=wx.LB_SINGLE, size=(-1, 80))        self.source_list.SetName(_("Source folders list"))        sHelper.addItem(self.source_list, proportion=1, flag=wx.EXPAND)        self.remove_source_btn = wx.Button(self, label=_("Remove selected source"))        sHelper.addItem(self.remove_source_btn)        sHelper.addItem(wx.StaticText(self, label=""))        sHelper.addItem(wx.StaticText(self, label=_("Destination folders:")))        self.dest_list = wx.ListBox(self, style=wx.LB_SINGLE, size=(-1, 120))        self.dest_list.SetName(_("Destination folders list"))        sHelper.addItem(self.dest_list, proportion=1, flag=wx.EXPAND)        btn_sizer = wx.BoxSizer(wx.HORIZONTAL)        add_btn = wx.Button(self, label=_("Add destination folder"))        remove_btn = wx.Button(self, label=_("Remove selected destination"))        btn_sizer.Add(add_btn, 1, wx.RIGHT, 5)        btn_sizer.Add(remove_btn, 1)        sHelper.addItem(btn_sizer)        sHelper.addItem(wx.StaticText(self, label=""))        self.sync_checkbox = sHelper.addItem(wx.CheckBox(self, label=_("Enable automatic synchronization")))        self.sync_checkbox.SetValue(False)        sHelper.addItem(wx.StaticText(self, label=_("Synchronization interval:")))        self.interval_combo = wx.ComboBox(self, choices=[            _("15 minutes"), _("30 minutes"), _("1 hour"),            _("1 day"), _("7 days"), _("15 days"), _("1 month")        ], style=wx.CB_READONLY)        self.interval_combo.SetSelection(0)        self.interval_combo.Enable(False)        sHelper.addItem(self.interval_combo)        self.time_panel = wx.Panel(self)        time_sizer = wx.BoxSizer(wx.HORIZONTAL)        time_sizer.Add(wx.StaticText(self.time_panel, label=_("Scheduled time:")), flag=wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, border=5)        self.time_ctrl = wx.TextCtrl(self.time_panel, value=self.scheduled_time, size=(60,-1))        time_sizer.Add(self.time_ctrl)        self.time_panel.SetSizer(time_sizer)        self.time_panel.Hide()        sHelper.addItem(self.time_panel)        btn_sizer2 = wx.BoxSizer(wx.HORIZONTAL)        clear_btn = wx.Button(self, label=_("Clear all settings"))        sync_btn = wx.Button(self, label=_("Start synchronization"))        ok_btn = wx.Button(self, label=_("OK"))        cancel_btn = wx.Button(self, label=_("Cancel"))        btn_sizer2.Add(clear_btn, 1, wx.RIGHT, 5)        btn_sizer2.Add(sync_btn, 1, wx.RIGHT, 5)        btn_sizer2.Add(ok_btn, 1, wx.RIGHT, 5)        btn_sizer2.Add(cancel_btn, 1)        sHelper.addItem(btn_sizer2, flag=wx.ALIGN_CENTER)        mainSizer.Add(sHelper.sizer, 1, wx.EXPAND|wx.ALL, 10)        self.SetSizer(mainSizer)        mainSizer.Fit(self)        self.SetSize((620, 680))        self.CentreOnScreen()        self.populateSourceList()        if self.existing_config:            self.loadExistingConfig()        elif self.source_path:            self.loadConfigForSource(self.source_path)        self.source_list.Bind(wx.EVT_LISTBOX, self.onSourceSelected)        add_btn.Bind(wx.EVT_BUTTON, self.onAddDestination)        remove_btn.Bind(wx.EVT_BUTTON, self.onRemoveDestination)        self.remove_source_btn.Bind(wx.EVT_BUTTON, self.onRemoveSource)        self.sync_checkbox.Bind(wx.EVT_CHECKBOX, self.onSyncCheck)        self.interval_combo.Bind(wx.EVT_COMBOBOX, self.onIntervalChange)        clear_btn.Bind(wx.EVT_BUTTON, self.onClear)        sync_btn.Bind(wx.EVT_BUTTON, self.onSync)        ok_btn.Bind(wx.EVT_BUTTON, self.onOk)        cancel_btn.Bind(wx.EVT_BUTTON, self.onCancel)        self.Bind(wx.EVT_CLOSE, self.onCancel)    def populateSourceList(self):        all_sources = []        if self.all_configs:            for c in self.all_configs:                if 'source' in c:                    all_sources.append(c['source'])        if self.source_path and self.source_path not in all_sources:            all_sources.insert(0, self.source_path)        elif self.source_path:            all_sources.remove(self.source_path)            all_sources.insert(0, self.source_path)        for s in all_sources:            self.source_list.Append(s)        if self.source_path:            for i in range(self.source_list.GetCount()):                if self.source_list.GetString(i) == self.source_path:                    self.source_list.SetSelection(i)                    break    def loadConfigForSource(self, path=None):        path = path or self.source_path        self.current_config = next((c for c in self.all_configs if c.get('source') == path), None)        if self.current_config:            self.loadExistingConfig()        else:            self.destinations = []            self.dest_list.Clear()            self.sync_checkbox.SetValue(False)            self.interval_combo.SetSelection(0)            self.interval_combo.Enable(False)            self.time_panel.Hide()            self.time_ctrl.SetValue(datetime.now().strftime("%H:%M"))    def loadExistingConfig(self):        config = self.current_config or self.existing_config        if not config:            return        self.destinations = config.get('destinations', [])        self.dest_list.Clear()        for d in self.destinations:            self.dest_list.Append(d)        self.sync_checkbox.SetValue(config.get('enabled', False))        interval = config.get('interval', 900)        intervals = [900, 1800, 3600, 86400, 604800, 1296000, 2592000]        if interval in intervals:            self.interval_combo.SetSelection(intervals.index(interval))        self.scheduled_time = config.get('scheduled_time', datetime.now().strftime("%H:%M"))        self.time_ctrl.SetValue(self.scheduled_time)        self.updateTimePanelVisibility()        self.interval_combo.Enable(self.sync_checkbox.GetValue())    def updateTimePanelVisibility(self):        idx = self.interval_combo.GetSelection()        if idx != wx.NOT_FOUND and idx >= 3:            self.time_panel.Show()        else:            self.time_panel.Hide()        self.Layout()    def onSourceSelected(self, evt):        sel = self.source_list.GetSelection()        if sel != wx.NOT_FOUND:            self.source_path = self.source_list.GetString(sel)            self.loadConfigForSource(self.source_path)    def onAddDestination(self, evt):        with wx.DirDialog(self, _("Choose destination folder")) as dlg:            if dlg.ShowModal() == wx.ID_OK:                path = dlg.GetPath()                if path not in self.destinations:                    self.destinations.append(path)                    self.dest_list.Append(path)                    self.dest_list.SetSelection(self.dest_list.GetCount() - 1)    def onRemoveDestination(self, evt):        sel = self.dest_list.GetSelection()        if sel != wx.NOT_FOUND:            self.destinations.pop(sel)            self.dest_list.Delete(sel)    def onRemoveSource(self, evt):        sel = self.source_list.GetSelection()        if sel != wx.NOT_FOUND:            self.removed_source = self.source_list.GetString(sel)            self.source_list.Delete(sel)            if self.source_list.GetCount() > 0:                self.source_list.SetSelection(0)                self.source_path = self.source_list.GetString(0)                self.loadConfigForSource(self.source_path)            else:                self.source_path = None                self.destinations = []                self.dest_list.Clear()                self.sync_checkbox.SetValue(False)    def onSyncCheck(self, evt):        self.interval_combo.Enable(self.sync_checkbox.GetValue())        self.updateTimePanelVisibility()    def onIntervalChange(self, evt):        self.updateTimePanelVisibility()    def onClear(self, evt):        self.destinations = []        self.dest_list.Clear()        self.sync_checkbox.SetValue(False)        self.interval_combo.SetSelection(0)        self.interval_combo.Enable(False)        self.time_panel.Hide()        self.time_ctrl.SetValue(datetime.now().strftime("%H:%M"))    def validateTime(self, t):        try:            if len(t) != 5 or t[2] != ':':                return False            h, m = int(t[:2]), int(t[3:])            return 0 <= h <= 23 and 0 <= m <= 59        except:            return False    def onSync(self, evt):        if not self.source_path or not self.destinations:            ui.message(_("Source and destination required"))            return        if self.time_panel.IsShown() and not self.validateTime(self.time_ctrl.GetValue()):            ui.message(_("Invalid time format"))            return        ui.message(_("Starting immediate mirror sync..."))        def sync_thread():            success = 0            log_file = os.path.join(tempfile.gettempdir(), "robocopy_mirror_manual.log")            try:                for dest in self.destinations:                    cmd = [                        'robocopy', self.source_path, dest,                        '/MIR', '/E', '/COPYALL', '/DCOPY:DAT',                        '/R:3', '/W:5', '/MT:32',                        '/NP', '/NFL', '/NDL',                        '/LOG+:' + log_file                    ]                    p = subprocess.Popen(                        cmd,                        creationflags=subprocess.CREATE_NO_WINDOW,                        stdout=subprocess.DEVNULL,                        stderr=subprocess.DEVNULL                    )                    p.wait()                    if p.returncode <= 7:                        success += 1                wx.CallAfter(ui.message, _("Immediate sync completed: {}/{} destinations").format(success, len(self.destinations)))                wx.CallAfter(tones.beep, 1500, 500)            except Exception as e:                log.error(f"Manual sync error: {e}")                wx.CallAfter(ui.message, _("Sync error occurred"))        threading.Thread(target=sync_thread, daemon=True).start()    def onOk(self, evt):        if not self.source_path or not self.destinations:            ui.message(_("Source and destination required"))            return        if self.time_panel.IsShown() and not self.validateTime(self.time_ctrl.GetValue()):            ui.message(_("Invalid time format"))            return        self.sync_enabled = self.sync_checkbox.GetValue()        idx = self.interval_combo.GetSelection()        intervals = [900, 1800, 3600, 86400, 604800, 1296000, 2592000]        self.sync_interval = intervals[idx] if 0 <= idx < len(intervals) else 900        self.scheduled_time = self.time_ctrl.GetValue()        self.EndModal(wx.ID_OK)    def onCancel(self, evt):        self.EndModal(wx.ID_CANCEL)class RobocopyManager:    def __init__(self, plugin):        self.plugin = plugin        self.pending_source = None        self.pending_operation = None        self.mirror_timers = {}        self.mirror_configs = []        self.loadMirrorConfig()    def cleanup(self):        for data in list(self.mirror_timers.values()):            t = data.get('timer')            if t and t.is_alive():                t.cancel()        self.mirror_timers.clear()    def loadMirrorConfig(self):        try:            path = os.path.join(globalVars.appArgs.configPath, "mirror.json")            if not os.path.exists(path):                return            with open(path, 'r', encoding='utf-8') as f:                data = json.load(f)                self.mirror_configs = data if isinstance(data, list) else []            for cfg in self.mirror_configs:                if cfg.get('enabled', False):                    self.startMirrorTimer(cfg, announce=False)        except Exception as e:            log.error(f"Load mirror config error: {e}")    def saveMirrorConfig(self):        try:            path = os.path.join(globalVars.appArgs.configPath, "mirror.json")            with open(path, 'w', encoding='utf-8') as f:                json.dump(self.mirror_configs, f, indent=2, ensure_ascii=False)        except Exception as e:            log.error(f"Save mirror config error: {e}")    def calculateNextRunTime(self, cfg):        """Calculate next run time based on interval and scheduled time"""        interval = cfg.get('interval', 900)        st = cfg.get('scheduled_time', '00:00')        now = datetime.now()                # For intervals less than a day, just add the interval        if interval < 86400:            return now + timedelta(seconds=interval)                # For daily or longer intervals, use scheduled time        try:            h, m = map(int, st.split(':'))            target = now.replace(hour=h, minute=m, second=0, microsecond=0)                        # If target time has passed today, calculate next occurrence            if target <= now:                if interval == 86400:  # 1 day                    target += timedelta(days=1)                elif interval == 604800:  # 7 days                    target += timedelta(days=7)                elif interval == 1296000:  # 15 days                    target += timedelta(days=15)                elif interval == 2592000:  # 30 days (1 month)                    # Approximate month as 30 days                    target += timedelta(days=30)                        return target        except:            return now + timedelta(seconds=interval)    def startMirrorTimer(self, cfg, announce=True):        src = cfg.get('source')        if not src or not os.path.exists(src):            return        if src in self.mirror_timers:            old = self.mirror_timers[src].get('timer')            if old and old.is_alive():                old.cancel()                # Calculate delay until next run        next_run = self.calculateNextRunTime(cfg)        delay = max(0, (next_run - datetime.now()).total_seconds())                timer = threading.Timer(delay, lambda: wx.CallAfter(self.executeMirrorBackup, cfg))        timer.daemon = True        timer.start()                self.mirror_timers[src] = {'timer': timer, 'next_run': next_run}                if announce:            next_time = next_run.strftime("%H:%M %d/%m/%Y")            ui.message(_("Next scheduled backup for {}: {}").format(                os.path.basename(src) if len(src) < 50 else src[:50] + "...",                next_time            ))    def executeMirrorBackup(self, cfg):        src = cfg.get('source')        dests = cfg.get('destinations', [])        if not src or not dests:            return        wx.CallAfter(ui.message, _("Scheduled mirror backup started for {}").format(            os.path.basename(src) if len(src) < 50 else src[:50] + "..."        ))        log_file = os.path.join(tempfile.gettempdir(), "robocopy_mirror_scheduled.log")        def run():            success = 0            for d in dests:                cmd = [                    'robocopy', src, d,                    '/MIR', '/E', '/COPYALL', '/DCOPY:DAT',                    '/R:3', '/W:5', '/MT:32',                    '/NP', '/NFL', '/NDL',                    '/LOG+:' + log_file                ]                p = subprocess.Popen(                    cmd,                    creationflags=subprocess.CREATE_NO_WINDOW,                    stdout=subprocess.DEVNULL,                    stderr=subprocess.DEVNULL                )                p.wait()                if p.returncode <= 7:                    success += 1            wx.CallAfter(ui.message, _("Scheduled backup completed: {}/{} destinations").format(success, len(dests)))            wx.CallAfter(tones.beep, 1500, 500)                        # Restart timer for next run            if cfg.get('enabled', False):                wx.CallAfter(self.startMirrorTimer, cfg, announce=True)        threading.Thread(target=run, daemon=True).start()    def getMirrorConfig(self, path):        return next((c for c in self.mirror_configs if c.get('source') == path), None)    def showMirrorBackupDialog(self):        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("Not in File Explorer"))            return        items, _ = self.plugin._getSelectedItems()        if not items or len(items) > 1:            ui.message(_("Please select only one folder"))            return        src = items[0][1]        if not os.path.isdir(src):            ui.message(_("Please select a folder"))            return        existing = self.getMirrorConfig(src)        dlg = MirrorBackupDialog(gui.mainFrame, src, existing, self.mirror_configs)        dlg._robocopy_manager = self        def callback(result):            if hasattr(dlg, 'removed_source') and dlg.removed_source:                self.mirror_configs = [c for c in self.mirror_configs if c.get('source') != dlg.removed_source]                if dlg.removed_source in self.mirror_timers:                    t = self.mirror_timers[dlg.removed_source].get('timer')                    if t and t.is_alive():                        t.cancel()                    del self.mirror_timers[dlg.removed_source]                self.saveMirrorConfig()            if result == wx.ID_OK and dlg.source_path:                self.setupMirrorBackup(                    dlg.source_path, dlg.destinations,                    dlg.sync_enabled, dlg.sync_interval, dlg.scheduled_time                )        gui.runScriptModalDialog(dlg, callback)    def setupMirrorBackup(self, src, dests, enabled, interval, time_str="00:00"):        self.mirror_configs = [c for c in self.mirror_configs if c.get('source') != src]        if src in self.mirror_timers:            t = self.mirror_timers[src].get('timer')            if t and t.is_alive():                t.cancel()            del self.mirror_timers[src]        if enabled and dests:            cfg = {                'source': src,                'destinations': dests,                'enabled': True,                'interval': interval,                'scheduled_time': time_str,                'last_updated': datetime.now().isoformat()            }            self.mirror_configs.append(cfg)            self.startMirrorTimer(cfg, announce=True)            ui.message(_("Mirror backup configured successfully"))        else:            ui.message(_("Mirror backup disabled"))        self.saveMirrorConfig()    def copy(self):        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("Not in File Explorer"))            return        items, _ = self.plugin._getSelectedItems()        if not items or len(items) > 1:            ui.message(_("Select one item only"))            return        self.pending_source = items[0][1]        self.pending_operation = 'copy'        ui.message(_("Source for copy: {}").format(os.path.basename(self.pending_source)))    def move(self):        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("Not in File Explorer"))            return        items, _ = self.plugin._getSelectedItems()        if not items or len(items) > 1:            ui.message(_("Select one item only"))            return        self.pending_source = items[0][1]        self.pending_operation = 'move'        ui.message(_("Source for move: {}").format(os.path.basename(self.pending_source)))    def paste(self):        if not self.pending_source or not self.pending_operation:            ui.message(_("No pending operation"))            return                # Get destination from current folder in Explorer        focus = api.getFocusObject()        if not focus or focus.appModule.appName != "explorer":            ui.message(_("Not in File Explorer"))            return                try:            shell = self.plugin._getActiveExplorerWindow()            if not shell:                ui.message(_("Cannot get destination"))                return                        # Get destination path            dest = urllib.parse.unquote(shell.LocationURL[8:])            if not os.path.isdir(dest):                ui.message(_("Invalid destination"))                return                        is_move = self.pending_operation == 'move'            operation_name = _("Move") if is_move else _("Copy")                        # Show initial message            ui.message(_("Starting {} operation in background...").format(operation_name))            tones.beep(800, 100)                        # Run operation in background thread            threading.Thread(target=self._execute_paste_operation,                            args=(dest, is_move, operation_name),                            daemon=True).start()                    except Exception as e:            log.error(f"Paste setup error: {e}")            ui.message(_("Error: {}").format(str(e)))            self.pending_source = self.pending_operation = None    def _execute_paste_operation(self, dest, is_move, operation_name):        """Execute paste operation in background thread"""        try:            # Check if source exists            if not os.path.exists(self.pending_source):                wx.CallAfter(ui.message, _("Source does not exist"))                return                        # Check if source is a directory or file            source_is_dir = os.path.isdir(self.pending_source)                        # Get file size for progress estimation            total_size = 0            if not source_is_dir:                try:                    total_size = os.path.getsize(self.pending_source)                except:                    pass            else:                # For directories, we can't easily get total size without scanning                # We'll use a different approach for progress                pass                        # Build optimized robocopy command for maximum speed            if source_is_dir:                source_dir = self.pending_source                dest_dir = os.path.join(dest, os.path.basename(source_dir))                                # Check if destination already exists                if os.path.exists(dest_dir):                    wx.CallAfter(ui.message, _("Destination already exists, overwriting..."))                                cmd = [                    'robocopy', source_dir, dest_dir,                    '/E',  # Copy subdirectories, including empty ones                    '/COPYALL',  # Copy all file info                    '/DCOPY:DAT',  # Copy directory timestamps                    '/R:1',  # Retry only once for speed                    '/W:1',  # Wait 1 second between retries                    '/MT:128',  # Use 128 threads for maximum speed                    '/NP',  # No progress percentage                    '/NFL',  # No file list                    '/NDL',  # No directory list                    '/NJH',  # No job header                    '/NJS',  # No job summary                    '/J',  # Use unbuffered I/O for large files                    '/FFT',  # Assume FAT file times                    '/DCOPY:T',  # Copy directory timestamps                    '/ZB',  # Restartable mode for large files                    '/V',  # Verbose output                    '/XD', '$RECYCLE.BIN', 'System Volume Information',  # Exclude system folders                    '/XA:SH',  # Exclude hidden system files                    '/XJ',  # Exclude junction points                    '/NOOFFLOAD'  # Disable offloading to hardware                ]            else:                source_file = self.pending_source                dest_file_path = dest                                cmd = [                    'robocopy', os.path.dirname(source_file), dest_file_path,                    os.path.basename(source_file),  # Specify the file name                    '/COPYALL',  # Copy all file info                    '/R:1',  # Retry only once for speed                    '/W:1',  # Wait 1 second between retries                    '/MT:128',  # Use 128 threads for maximum speed                    '/NP',  # No progress percentage                    '/NFL',  # No file list                    '/NDL',  # No directory list                    '/NJH',  # No job header                    '/NJS',  # No job summary                    '/J',  # Use unbuffered I/O for large files                    '/FFT',  # Assume FAT file times                    '/ZB',  # Restartable mode for large files                    '/V',  # Verbose output                    '/NOOFFLOAD'  # Disable offloading to hardware                ]                        # For very large files (over 1GB), add compression for network transfer            if total_size > 1073741824:  # 1GB                cmd.append('/COMPRESS')                wx.CallAfter(ui.message, _("Large file detected, using compression for speed"))                        if is_move:                cmd.append('/MOVE')  # Move files and directories                        # Create log file            log_file = os.path.join(tempfile.gettempdir(), f"robocopy_{operation_name.lower()}_{int(time.time())}.log")            cmd.append(f'/LOG+:{log_file}')                        # Announce start            wx.CallAfter(ui.message, _("{} started. You can continue working while it runs in background.").format(operation_name))                        # Start timer for progress updates            start_time = time.time()            last_progress_update = start_time            last_size_check = start_time                        # Start robocopy process without blocking            process = subprocess.Popen(                cmd,                creationflags=subprocess.CREATE_NO_WINDOW,                stdout=subprocess.DEVNULL,                stderr=subprocess.DEVNULL            )                        # Monitor process without blocking            while process.poll() is None:                current_time = time.time()                elapsed = current_time - start_time                                # Update progress every 5 seconds                if current_time - last_progress_update >= 5:                    # Calculate estimated speed                    if source_is_dir or total_size == 0:                        # For directories or unknown size, just report elapsed time                        wx.CallAfter(ui.message, _("{} in progress... {} seconds elapsed").format(                            operation_name, int(elapsed)))                    else:                        # For single files, check destination file size                        if current_time - last_size_check >= 2:                            dest_file = os.path.join(dest, os.path.basename(self.pending_source))                            copied_size = 0                            try:                                if os.path.exists(dest_file):                                    copied_size = os.path.getsize(dest_file)                            except:                                pass                                                        if total_size > 0 and copied_size > 0:                                percentage = int((copied_size / total_size) * 100)                                speed_mbps = (copied_size / (1024 * 1024)) / elapsed if elapsed > 0 else 0                                                                # Play tone based on progress                                if percentage % 25 == 0:                                    if percentage == 25:                                        wx.CallAfter(tones.beep, 800, 100)                                    elif percentage == 50:                                        wx.CallAfter(tones.beep, 1000, 100)                                    elif percentage == 75:                                        wx.CallAfter(tones.beep, 1200, 100)                                                                wx.CallAfter(ui.message, _("{}: {}% complete, speed: {:.1f} MB/s").format(                                    operation_name, percentage, speed_mbps))                                                        last_size_check = current_time                                        last_progress_update = current_time                                # Small sleep to prevent high CPU usage                time.sleep(0.5)                        # Get return code            return_code = process.returncode                        # Success codes are 0-7 for robocopy            if return_code <= 7:                elapsed_total = time.time() - start_time                if total_size > 0:                    speed_mbps = (total_size / (1024 * 1024)) / elapsed_total if elapsed_total > 0 else 0                    wx.CallAfter(ui.message, _("{} completed successfully in {:.1f} seconds, average speed: {:.1f} MB/s").format(                        operation_name, elapsed_total, speed_mbps))                else:                    wx.CallAfter(ui.message, _("{} completed successfully in {:.1f} seconds").format(                        operation_name, elapsed_total))                wx.CallAfter(tones.beep, 1500, 300)                                # Refresh Explorer window to show new files                try:                    shell = self.plugin._getActiveExplorerWindow()                    if shell:                        shell.Refresh()                except:                    pass            elif return_code == 16:                # Serious error - try alternative method                wx.CallAfter(ui.message, _("Trying alternative copy method..."))                                # Try using shutil for large files or problematic copies                try:                    if source_is_dir:                        if is_move:                            shutil.move(self.pending_source, os.path.join(dest, os.path.basename(self.pending_source)))                        else:                            shutil.copytree(self.pending_source, os.path.join(dest, os.path.basename(self.pending_source)))                    else:                        if is_move:                            shutil.move(self.pending_source, os.path.join(dest, os.path.basename(self.pending_source)))                        else:                            shutil.copy2(self.pending_source, dest)                                        wx.CallAfter(ui.message, _("{} completed successfully using alternative method").format(operation_name))                    wx.CallAfter(tones.beep, 1500, 300)                except Exception as alt_e:                    log.error(f"Alternative method error: {alt_e}")                    wx.CallAfter(ui.message, _("{} failed with error: {}").format(operation_name, str(alt_e)))                    wx.CallAfter(tones.beep, 500, 300)            else:                wx.CallAfter(ui.message, _("{} completed with warnings (code: {})").format(operation_name, return_code))                wx.CallAfter(tones.beep, 1000, 200)                    except Exception as e:            log.error(f"Paste error: {e}")            wx.CallAfter(ui.message, _("Error during {}: {}").format(operation_name, str(e)))            wx.CallAfter(tones.beep, 500, 300)        finally:            # Reset pending operation            self.pending_source = self.pending_operation = None